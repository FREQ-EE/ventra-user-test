<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ventra · EXHALE//ASCEND</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;800;900&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root { color-scheme: dark light; }

    :root{
      /* Screen shaping */
      --screen-radius: 30px;
      --screen-curve: 0.0;            /* kept, but NOT used */
      --screen-bloom: 0.25;
      --screen-bloom-blur: 2px;
      --screen-bloom-spread: 2px;

      /* Glass curvature strength (highlight/vignette only) */
      --glass-strength: 1.75;         /* 0.0 .. 2.0 */
    }

    :root{
      --bg:#0F1011; --card:#13151C; --text:#EDF4FA; --muted:#9AA4B2; --border:#262C3C;
      --accentA:#8B5CF6; --accentB:#EC4899; --warn:#FFB86B; --danger:#FF6B6B;

      /* Game background gradient alphas (set from JS via GAME_BG_INTENSITY) */
      --gA:0.18;
      --gB:0.15;
      --gC0:0.12;
      --gC1:0.00;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#FFFFFF; --card:#FFFFFF; --text:#0B0D10; --muted:#556170; --border:#E5E7EB;
        --accentA:#7C3AED; --accentB:#DB2777; --warn:#B86B00; --danger:#B42318;
        --gA:0.18; --gB:0.15; --gC0:0.12; --gC1:0.00;
      }
    }

    html, body { height: 100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      line-height:1.35;
    }

    .wrap{ max-width:980px; margin:0 auto; padding:18px 18px 28px; display:grid; gap:14px; }
    header{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap; }

    h1{
      margin:0;
      font-family:"Orbitron", system-ui, sans-serif;
      font-weight:900;
      font-size:18px;
      letter-spacing:0.02em;
      background:linear-gradient(90deg, var(--accentA), var(--accentB));
      -webkit-background-clip:text; background-clip:text; color:transparent;
    }

    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    a{ color:inherit; text-decoration:none; }
    a:hover{ text-decoration:underline; }

    .pill{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:rgba(0,0,0,0.10);
      font-size:12px;
      color:var(--muted);
      font-variant-numeric:tabular-nums;
      white-space:nowrap;
      user-select:none;
    }

    #ccPill { min-width: 86px; justify-content: center; }

    button{ font:inherit; color:inherit; }
    .iconBtn{
      border:1px solid var(--border);
      border-radius:999px;
      background:rgba(0,0,0,0.10);
      padding:6px 10px;
      line-height:1;
      cursor:pointer;
      display:inline-flex; align-items:center; gap:8px;
      color:var(--muted);
      transition: border-color 120ms ease, color 120ms ease;
    }
    .iconBtn:hover{ border-color:var(--accentA); color:var(--text); }
    .iconBtn svg{ width:18px; height:18px; pointer-events:none; }
    .iconOn, .iconOff{ display:none; }
    .iconBtn[data-on="1"] .iconOn{ display:block; }
    .iconBtn[data-on="0"] .iconOff{ display:block; }

    /* Game shell (4:3) */
    .gameShell{
      position:relative;
      overflow:visible;
      border-radius:var(--screen-radius);
      border:1px solid var(--border);

      width:100%;
      aspect-ratio: 4 / 3;
      max-height: 78vh;

      background-color:#000;
      background:
        radial-gradient(900px 320px at 10% 0%, rgba(139,92,246,var(--gA)), transparent 70%),
        radial-gradient(900px 320px at 90% 0%, rgba(236,72,153,var(--gB)), transparent 70%),
        linear-gradient(180deg, rgba(0,0,0,var(--gC0)), rgba(0,0,0,var(--gC1)));

      box-shadow:
        0 0 var(--screen-bloom-blur) var(--screen-bloom-spread) rgba(139,92,246, calc(0.25 * var(--screen-bloom))),
        0 0 calc(var(--screen-bloom-blur) * 0.9) var(--screen-bloom-spread) rgba(236,72,153, calc(0.20 * var(--screen-bloom))),
        0 0 calc(var(--screen-bloom-blur) * 1.2) 0 rgba(255,255,255, calc(0.06 * var(--screen-bloom)));
    }

    /* The glass "screen" MUST fill the shell */
    .gameShell > .screen{
      position:absolute;
      inset:0;
      overflow:hidden;
      border-radius:inherit;
    }

    /* Glass curvature illusion (highlight/vignette only) */
    .gameShell > .screen::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      border-radius:inherit;
      z-index:2;

      background:
        radial-gradient(140% 105% at 50% 16%,
          rgba(255,255,255, calc(0.13 * var(--glass-strength))),
          transparent 48%),
        radial-gradient(140% 140% at 50% 55%,
          transparent 56%,
          rgba(0,0,0, calc(0.42 * var(--glass-strength))) 100%),
        radial-gradient(120% 90% at 20% 10%,
          rgba(255,255,255, calc(0.06 * var(--glass-strength))),
          transparent 55%),
        radial-gradient(120% 90% at 80% 10%,
          rgba(255,255,255, calc(0.05 * var(--glass-strength))),
          transparent 55%);

      mix-blend-mode: soft-light;
      opacity: 1;
    }

    .gameShell > .screen::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      border-radius:inherit;
      z-index:2;

      background:
        radial-gradient(110% 110% at 50% 50%,
          transparent 60%,
          rgba(0,0,0, calc(0.55 * var(--glass-strength))) 100%),
        radial-gradient(90% 120% at 50% 110%,
          rgba(0,0,0, calc(0.22 * var(--glass-strength))),
          transparent 55%),
        radial-gradient(120% 90% at -10% 50%,
          rgba(0,0,0, calc(0.20 * var(--glass-strength))),
          transparent 50%),
        radial-gradient(120% 90% at 110% 50%,
          rgba(0,0,0, calc(0.20 * var(--glass-strength))),
          transparent 50%);

      mix-blend-mode: multiply;
      opacity: 0.95;
    }

    canvas{ display:block; width:100%; height:100%; position:relative; z-index:0; }

    /* DOM CRT layer is kept but hidden (CRT is now drawn into the canvas so it gets barrel-distorted) */
    #crtOverlay{ display:none; }

    .hud{
      position:absolute;
      top:10px; left:10px; right:10px;
      display:flex; justify-content:space-between; gap:10px;
      pointer-events:none;
      font-size:12px;
      color:var(--muted);
      z-index:3;
    }

    .hudItem{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.10);
      white-space:nowrap;
      font-variant-numeric:tabular-nums;
    }

    .overlay{
      position:absolute;
      inset:0;
      display:grid; place-items:center;
      pointer-events:none;
      padding:18px;
      text-align:center;
      z-index:4;
    }

    .overlayBox{
      max-width:620px; width:100%;
      border-radius:16px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.16);
      padding:14px;
      box-shadow:0 10px 40px rgba(0,0,0,0.25);
    }
    .overlayTitle{
      font-family:"Orbitron", system-ui, sans-serif;
      font-weight:900;
      margin:0 0 8px;
      font-size:14px;
      letter-spacing:0.02em;
      color:var(--text);
    }
    .overlayText{ margin:0; font-size:12px; color:var(--muted); }
    .kbd{
      display:inline-block;
      padding:2px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.10);
      color:var(--text);
      font-size:12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>VENTRA · EXHALE//ASCEND</h1>
      </div>

      <div class="row" aria-label="Status">
        <span class="pill" id="ventraPill">Ventra not connected — plug in and refresh</span>
        <span class="pill" id="ccPill">CC2: 000</span>

        <button class="iconBtn" id="audioToggle" type="button" data-on="0" aria-label="Toggle music" title="Toggle music">
          <svg class="iconOn" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M3 10v4h4l5 4V6L7 10H3zm13.5 2a3.5 3.5 0 0 0-1.5-2.9v5.8A3.5 3.5 0 0 0 16.5 12zm0-7a1 1 0 0 0-.7 1.7A8 8 0 0 1 18 12a8 8 0 0 1-2.2 5.3 1 1 0 1 0 1.4 1.4A10 10 0 0 0 20 12a10 10 0 0 0-2.8-6.7 1 1 0 0 0-.7-.3z"/>
          </svg>
          <svg class="iconOff" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M3 10v4h4l5 4V6L7 10H3zm13.1 2 2.8 2.8 1.4-1.4L17.5 10.6l2.8-2.8-1.4-1.4L16.1 9.2l-2.8-2.8-1.4 1.4 2.8 2.8-2.8 2.8 1.4 1.4L16.1 12z"/>
          </svg>
        </button>

        <span class="pill"><a href="./index.html" title="Back to instructions & feedback">Back</a></span>

        <button class="iconBtn" id="helpBtn" type="button"
                aria-label="Help"
                title="Browser & MIDI help">?</button>
      </div>
    </header>

    <div class="gameShell" id="gameShell" aria-label="Ventra game">
      <div class="screen">
        <div class="hud">
          <div class="hudItem" id="hudTime">Time: 0.0 s</div>
          <div class="hudItem" id="hudSpeed">Speed: 0</div>
        </div>

        <canvas id="game"></canvas>
        <div id="crtOverlay" aria-hidden="true"></div>

        <div class="overlay" id="overlay">
          <div class="overlayBox">
            <p class="overlayTitle" id="overlayTitle">Ready</p>
            <p class="overlayText" id="overlayText">
              Start with <span class="kbd">three breath pulses</span>.
            </p>
          </div>
        </div>
      </div>
    </div>

    <dialog id="helpDialog" style="
      border:1px solid var(--border);
      border-radius:16px;
      background:var(--card);
      color:var(--text);
      max-width:720px;
      padding:18px;
    ">
      <h3 style="margin-top:0;font-family:Orbitron,sans-serif;font-size:14px;">
        Browser & MIDI Setup
      </h3>

      <p style="font-size:12px;color:var(--muted);">
        Ventra uses WebMIDI. Support depends on browser.
      </p>

      <ul style="font-size:12px;line-height:1.6;padding-left:18px;margin:10px 0 0;">
        <li style="margin:10px 0;">
          <strong>Chrome / Edge (recommended):</strong>
          <span style="color:var(--muted); font-weight:400;">
            WebMIDI works natively. Plug in Ventra and refresh if not detected.
          </span>
        </li>

        <li style="margin:10px 0;">
          <strong>Firefox:</strong>
          <span style="color:var(--muted); font-weight:400;"><br>
            1) Close Firefox. Plug in Ventra. Reopen Firefox. (Otherwise Firefox may show no MIDI ports.)<br>
            2) When prompted, <strong>Allow MIDI device access</strong> (and SysEx if requested).<br>
            3) For music: click the speaker button once (autoplay is often blocked).<br>
            If MIDI still does not work: open <code>about:config</code> → set <code>dom.webmidi.enabled</code> to <code>true</code> → refresh.
          </span>
        </li>

        <li style="margin:10px 0;">
          <strong>Safari (macOS):</strong>
          <span style="color:var(--muted); font-weight:400;">
            Develop → Experimental Features → enable WebMIDI. Restart browser if required.
          </span>
        </li>
      </ul>

      <div style="text-align:right;margin-top:12px;">
        <button id="closeHelp" class="iconBtn" type="button">Close</button>
      </div>
    </dialog>

    <audio id="bgm" loop preload="auto">
      <source src="./music.ogg" type="audio/ogg">
      <source src="./music.mp3" type="audio/mpeg">
    </audio>
  </div>

  <script>
    'use strict';

    function clamp(n, lo, hi) { return Math.min(hi, Math.max(lo, n)); }

    function expApproach(current, target, dt, tau) {
      const a = 1 - Math.exp(-dt / Math.max(1e-6, tau));
      return current + (target - current) * a;
    }

    const SHOW_COLLISION_DEBUG = false;
    const COLL_FOLLOWS_SPRITE_TILT = true;
    const DEBUG_COLL_COLOUR = '#00FFFF';

    // ============================================================
    // Barrel distortion (lens bulge)
    // ============================================================
    const BARREL_ENABLED = true;
    const BARREL_K = 0.075;
    const BARREL_SLICES = 90;

    // ============================================================
    // CRT (now rendered into the off-screen scene, so it gets barrel distortion)
    // ============================================================
    const CRT_OPACITY = 0.15;
    const CRT_REPEATS_X = 98;
    const CRT_BRICK_OFFSET_FRAC = 1/2;

    // Canvas supports ctx.filter, but blend modes like "soft-light" vary by browser.
    // We approximate: use 'overlay' if available, else 'source-over'.
    const CRT_COMPOSITE = 'overlay';         // try: 'overlay', 'soft-light', 'multiply'
    const CRT_CONTRAST = 0.66;
    const CRT_BRIGHTNESS = 0.50;

    const crtImg = new Image();
    let crtImgReady = false;
    crtImg.onload = () => { crtImgReady = true; };
    crtImg.onerror = (e) => { console.warn('Failed to load overlay-pattern.png', e); };
    crtImg.src = './overlay-pattern.png';

    let crtPattern = null;
    let crtPatternTilePx = 0;
    let crtPatternShiftPx = -1;

    function ensureCrtPattern(w, h, dpr) {
      if (!crtImgReady) return null;

      const tileCssPx = Math.max(2, Math.round((w / dpr) / CRT_REPEATS_X));
      const shiftPx = Math.round(tileCssPx * CRT_BRICK_OFFSET_FRAC) % tileCssPx;

      if (crtPattern && tileCssPx === crtPatternTilePx && shiftPx === crtPatternShiftPx) return crtPattern;

      const tile = document.createElement('canvas');
      tile.width = tileCssPx;
      tile.height = tileCssPx;
      const tctx = tile.getContext('2d');
      tctx.clearRect(0, 0, tileCssPx, tileCssPx);
      tctx.drawImage(crtImg, 0, 0, tileCssPx, tileCssPx);

      const brick = document.createElement('canvas');
      brick.width = tileCssPx;
      brick.height = tileCssPx * 2;
      const bctx = brick.getContext('2d');
      bctx.clearRect(0, 0, brick.width, brick.height);
      bctx.drawImage(tile, 0, 0);
      bctx.drawImage(tile, -shiftPx, tileCssPx);
      bctx.drawImage(tile, tileCssPx - shiftPx, tileCssPx);

      // Convert to CanvasPattern for fast fill.
      const pat = ctx.createPattern(brick, 'repeat');
      crtPattern = pat;
      crtPatternTilePx = tileCssPx;
      crtPatternShiftPx = shiftPx;
      return pat;
    }

    const GAME_BG_INTENSITY = 0.6;
    const GAME_BG_BASE = { gA: 0.18, gB: 0.15, gC0: 0.12, gC1: 0.00 };

    function applyGameBgIntensity() {
      const r = document.documentElement;
      const k = Math.max(0, GAME_BG_INTENSITY);
      r.style.setProperty('--gA',  String(GAME_BG_BASE.gA  * k));
      r.style.setProperty('--gB',  String(GAME_BG_BASE.gB  * k));
      r.style.setProperty('--gC0', String(GAME_BG_BASE.gC0 * k));
      r.style.setProperty('--gC1', String(GAME_BG_BASE.gC1 * k));
    }
    applyGameBgIntensity();

    const monkeyImg = new Image();
    let monkeyReady = false;
    monkeyImg.onload = () => { monkeyReady = true; };
    monkeyImg.onerror = (e) => { console.warn('Failed to load monkey.svg', e); };
    monkeyImg.src = './monkey.svg';

    const MONKEY_DRAW_W = 150;
    const MONKEY_DRAW_H = 150;

    const MONKEY_BASE_STROKE_PX = 2;
    const MONKEY_GOLD_STROKE_PX = 4;
    const MONKEY_RED_STROKE_PX  = 4;
    const MONKEY_BLUE_STROKE_PX = 6;
    const MONKEY_AQUA_STROKE_PX = 6;

    const MONKEY_BASE_COLOUR = '#FFFFFF';
    const MONKEY_GOLD_COLOUR = '#FFCC33';
    const MONKEY_RED_COLOUR  = '#CC0033';
    const MONKEY_BLUE_COLOUR = '#00A3FF';
    const MONKEY_AQUA_COLOUR = '#00FFFF';

    const MONKEY_BASE_ALPHA = 0.66;
    const MONKEY_GLOW_ALPHA = 1;
    const MONKEY_AURA_ALPHA = 1;
    const MONKEY_BASE_PASSES = 3;

    const MONKEY_GLOW_BLUR_PX = 0.66;
    const MONKEY_AURA_BLUR_PX = 2;

    const MONKEY_GOLD_OFF_CSS = { x: -0,  y: 4 };
    const MONKEY_RED_OFF_CSS  = { x: -4,  y: 0 };
    const MONKEY_BLUE_OFF_CSS = { x: 4,   y: 0 };
    const MONKEY_AQUA_OFF_CSS = { x: 0,   y: 0 };

    const TAIL_X_CAP_S = 60;
    const TAIL_X_MAX_CSS = 18;
    const TAIL_Y_MAX_CSS = 20;
    const TAIL_VY_FOR_MAX = 1200;
    const TAIL_VY_TAU_S = 0.10;
    const TAIL_SCALE_MAX = 0.08;

    let tailVyFilt = 0;

    const monkeyMaskCanvas  = document.createElement('canvas');
    const monkeyLayerCanvas = document.createElement('canvas');
    let monkeyCacheW = 0;
    let monkeyCacheH = 0;

    function rebuildMonkeyCache(drawW, drawH) {
      const CACHE_SCALE = 2;
      const cw = Math.max(1, Math.round(drawW * CACHE_SCALE));
      const ch = Math.max(1, Math.round(drawH * CACHE_SCALE));

      monkeyCacheW = cw;
      monkeyCacheH = ch;

      monkeyMaskCanvas.width = cw;
      monkeyMaskCanvas.height = ch;
      monkeyLayerCanvas.width = cw;
      monkeyLayerCanvas.height = ch;

      const mctx = monkeyMaskCanvas.getContext('2d');
      mctx.setTransform(1, 0, 0, 1, 0, 0);
      mctx.clearRect(0, 0, cw, ch);
      mctx.drawImage(monkeyImg, 0, 0, cw, ch);
    }

    function ensureMonkeyCache(drawW, drawH) {
      if (!monkeyReady) return false;
      if (drawW !== monkeyCacheW || drawH !== monkeyCacheH) rebuildMonkeyCache(drawW, drawH);
      return true;
    }

    function makeTintedMonkeyLayer(colour, strokePxCss) {
      const lctx = monkeyLayerCanvas.getContext('2d');
      lctx.clearRect(0, 0, monkeyCacheW, monkeyCacheH);

      const strokePx = Math.max(0, strokePxCss * dpr);
      const half = Math.floor(strokePx / 2);

      lctx.globalCompositeOperation = 'source-over';
      for (let dx = -half; dx <= half; dx++) {
        for (let dy = -half; dy <= half; dy++) {
          lctx.drawImage(monkeyMaskCanvas, dx, dy);
        }
      }

      lctx.globalCompositeOperation = 'destination-in';
      lctx.drawImage(monkeyMaskCanvas, 0, 0);

      lctx.globalCompositeOperation = 'source-atop';
      lctx.fillStyle = colour;
      lctx.fillRect(0, 0, monkeyCacheW, monkeyCacheH);

      lctx.globalCompositeOperation = 'source-over';
    }

    function drawMonkeyNeon(x, y, tilt, drawW, drawH, extraScale = 1.0) {
      if (!ensureMonkeyCache(drawW, drawH)) return;

      const speedFactor = clamp(world.speed / world.baseSpeed, 1, 3.2);
      const tCap = clamp(world.survive / TAIL_X_CAP_S, 0, 1);

      const xNorm = clamp((speedFactor - 1) / (3.2 - 1), 0, 1) * tCap;
      const vNorm = clamp(Math.abs(tailVyFilt) / Math.max(1e-6, TAIL_VY_FOR_MAX), 0, 1);
      const ySign = (tailVyFilt >= 0) ? -1 : 1;

      const M_BLUE = 0.45;
      const M_GOLD = 0.70;
      const M_RED  = 1.00;

      const baseGold = { x: MONKEY_GOLD_OFF_CSS.x, y: MONKEY_GOLD_OFF_CSS.y };
      const baseRed  = { x: MONKEY_RED_OFF_CSS.x,  y: MONKEY_RED_OFF_CSS.y  };
      const baseBlue = { x: MONKEY_BLUE_OFF_CSS.x, y: MONKEY_BLUE_OFF_CSS.y };
      const baseAqua = { x: MONKEY_AQUA_OFF_CSS.x, y: MONKEY_AQUA_OFF_CSS.y };

      const xLagBlue = -TAIL_X_MAX_CSS * xNorm * M_BLUE;
      const xLagGold = -TAIL_X_MAX_CSS * xNorm * M_GOLD;
      const xLagRed  = -TAIL_X_MAX_CSS * xNorm * M_RED;

      const yLagBlue = (TAIL_Y_MAX_CSS * vNorm * M_BLUE) * ySign;
      const yLagGold = (TAIL_Y_MAX_CSS * vNorm * M_GOLD) * ySign;
      const yLagRed  = (TAIL_Y_MAX_CSS * vNorm * M_RED ) * ySign;

      const goldOff = { x: (baseGold.x + xLagGold) * dpr, y: (baseGold.y + yLagGold) * dpr };
      const redOff  = { x: (baseRed.x  + xLagRed ) * dpr, y: (baseRed.y  + yLagRed ) * dpr };
      const blueOff = { x: (baseBlue.x + xLagBlue) * dpr, y: (baseBlue.y + yLagBlue) * dpr };
      const aquaOff = { x: baseAqua.x * dpr, y: baseAqua.y * dpr };

      const sBlue = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_BLUE;
      const sGold = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_GOLD;
      const sRed  = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_RED;
      const sBase = 1.0;
      const sAura = 1.0;

      const layers = [
        { colour: MONKEY_AQUA_COLOUR, blurCss: MONKEY_AURA_BLUR_PX, dx: aquaOff.x, dy: aquaOff.y, stroke: MONKEY_AQUA_STROKE_PX, mode: 'hard-light', scale: sAura },
        { colour: MONKEY_GOLD_COLOUR, blurCss: MONKEY_GLOW_BLUR_PX, dx: goldOff.x, dy: goldOff.y, stroke: MONKEY_GOLD_STROKE_PX, mode: 'normal',     scale: sGold },
        { colour: MONKEY_RED_COLOUR,  blurCss: MONKEY_GLOW_BLUR_PX, dx: redOff.x,  dy: redOff.y,  stroke: MONKEY_RED_STROKE_PX,  mode: 'normal',     scale: sRed  },
        { colour: MONKEY_BLUE_COLOUR, blurCss: MONKEY_GLOW_BLUR_PX, dx: blueOff.x, dy: blueOff.y, stroke: MONKEY_BLUE_STROKE_PX, mode: 'normal',     scale: sBlue },
        { colour: MONKEY_BASE_COLOUR, blurCss: 0,                   dx: 0,         dy: 0,          stroke: MONKEY_BASE_STROKE_PX, mode: 'normal',     scale: sBase },
      ];

      for (const L of layers) {
        makeTintedMonkeyLayer(L.colour, L.stroke);

        ctx.save();
        ctx.translate(x + L.dx, y + L.dy);
        ctx.rotate(tilt);

        const sLocal = (L.scale && L.scale !== 1) ? (L.scale * extraScale) : extraScale;
        if (sLocal !== 1) ctx.scale(sLocal, sLocal);

        ctx.filter = (L.blurCss > 0)
          ? `blur(${(L.blurCss * dpr).toFixed(4)}px)`
          : 'none';

        ctx.globalCompositeOperation = (L.mode === 'hard-light') ? 'hard-light' : 'source-over';

        if (L.colour === MONKEY_BASE_COLOUR) ctx.globalAlpha = MONKEY_BASE_ALPHA;
        else if (L.colour === MONKEY_AQUA_COLOUR) ctx.globalAlpha = MONKEY_AURA_ALPHA;
        else ctx.globalAlpha = MONKEY_GLOW_ALPHA;

        const passes = (L.colour === MONKEY_BASE_COLOUR) ? MONKEY_BASE_PASSES : 1;
        for (let i = 0; i < passes; i++) {
          ctx.drawImage(monkeyLayerCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
        }

        ctx.restore();
      }

      ctx.globalAlpha = 1;
      ctx.filter = 'none';
      ctx.globalCompositeOperation = 'source-over';
    }

    const COLL_ROT_DEG = -24;
    const COLL_ROT = (COLL_ROT_DEG * Math.PI) / 180;
    const COLL_A_FRAC = 0.40;
    const COLL_B_FRAC = 0.15;
    const COLL_CX_OFF_FRAC = 0.05;
    const COLL_CY_OFF_FRAC = 0.03;

    const REST_EVERY_S = 25;
    const REST_COUNT = 3;
    const REST_COUNT_STEP_S = 1.75;
    const REST_PULSES = 3;

    const REST_FLYIN_SCALE_FROM = 1.00;
    const REST_BASE_SCALE = 1.50;
    const REST_PULSE_SCALE = 0.10;

    const REST_DIM_ALPHA = 0.18;
    const REST_MOVE_TAU_S = 0.22;
    const REST_RETURN_TAU_S = 0.18;

    const REST_CENTRE_X_FRAC = 0.50;
    const REST_CENTRE_Y_FRAC = 0.50;

    const REST_FLYIN_FRACTION = 0.55;
    const REST_RETURN_FRACTION = 0.25;
    const REST_UI_FADE_S = 0.25;

    function restDurationS() {
      return Math.max(0.2, REST_COUNT * REST_COUNT_STEP_S);
    }

    const SPEED_RAMP_PER_S = 16;
    const SPEED_TAU_S = 0.60;

    const targetChannel1Based = 1;
    const targetCC = 2;

    const ventraPill = document.getElementById('ventraPill');
    const ccPill = document.getElementById('ccPill');

    let midiAccess = null;
    let currentInput = null;

    function setVentraText(text) { ventraPill.textContent = text; }

    function detachCurrentInput() {
      if (currentInput) currentInput.onmidimessage = null;
      currentInput = null;
    }

    function isVentraPort(p) {
      const name = (p && p.name ? String(p.name) : '').toLowerCase();
      const manu = (p && p.manufacturer ? String(p.manufacturer) : '').toLowerCase();
      return name.includes('ventra') || manu.includes('ventra');
    }

    function findVentraInput() {
      if (!midiAccess) return null;
      const inputs = Array.from(midiAccess.inputs.values());
      return inputs.find(isVentraPort) || null;
    }

    function attachVentraIfPresent() {
      detachCurrentInput();
      const input = findVentraInput();
      if (!input) {
        setVentraText('Ventra not connected — plug in and refresh');
        return false;
      }
      currentInput = input;
      currentInput.onmidimessage = onMIDIMessage;
      setVentraText('Ventra connected');
      return true;
    }

    async function initMIDI() {
      if (!('requestMIDIAccess' in navigator)) {
        setVentraText('Ventra not supported in this browser');
        return;
      }

      try {
        midiAccess = await navigator.requestMIDIAccess({ sysex: false });
        attachVentraIfPresent();
        midiAccess.onstatechange = () => attachVentraIfPresent();
      } catch (err) {
        console.error(err);
        setVentraText('Ventra not enabled — refresh and allow MIDI');
      }
    }

    initMIDI();

    const audioToggle = document.getElementById('audioToggle');
    const bgm = document.getElementById('bgm');
    const AUDIO_KEY = 'ventra_game_music';

    function musicIsArmed() { return audioToggle.dataset.on === '1'; }

    async function startMusicIfArmed() {
      if (!bgm) return;
      if (!musicIsArmed()) return;
      try { await bgm.play(); }
      catch (e) { console.warn('Audio play failed:', e); }
    }

    function stopMusic() {
      if (!bgm) return;
      bgm.pause();
      bgm.currentTime = 0;
    }

    function setAudioUI(on) { audioToggle.dataset.on = on ? '1' : '0'; }

    async function setAudio(on) {
      localStorage.setItem(AUDIO_KEY, on ? '1' : '0');
      setAudioUI(on);

      if (!bgm) return;

      if (on) {
        if (world && world.started) startMusicIfArmed();
      } else {
        stopMusic();
      }
    }

    const saved = localStorage.getItem(AUDIO_KEY);
    setAudioUI(saved === null ? true : saved === '1');
    if (saved === null) localStorage.setItem(AUDIO_KEY, '1');

    audioToggle.addEventListener('click', () => {
      const next = audioToggle.dataset.on !== '1';
      setAudio(next);
    });

    const canvas = document.getElementById('game');
    const viewCtx = canvas.getContext('2d');

    const renderCanvas = document.createElement('canvas');
    const ctx = renderCanvas.getContext('2d');

    const distortCanvas = document.createElement('canvas');
    const dctx = distortCanvas.getContext('2d');

    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const hudTime = document.getElementById('hudTime');
    const hudSpeed = document.getElementById('hudSpeed');

    let cc2 = 0;

    function setCC2(v) {
      cc2 = clamp(v | 0, 0, 127);
      ccPill.textContent = `CC2: ${String(cc2).padStart(3, '0')}`;
    }

    const PULSE_THRESHOLD = 32;
    const PULSE_WINDOW_S = 1.6;
    let prevCC2 = 0;
    let pulseCount = 0;
    let pulseWindowT = 0;

    function resetPulses() {
      pulseCount = 0;
      pulseWindowT = 0;
      prevCC2 = cc2;
    }

    function registerPulse(dt) {
      if (!currentInput) {
        pulseCount = 0;
        pulseWindowT = 0;
        prevCC2 = cc2;
        return;
      }

      const rising = (prevCC2 < PULSE_THRESHOLD) && (cc2 >= PULSE_THRESHOLD);
      prevCC2 = cc2;

      if (pulseWindowT > 0) {
        pulseWindowT = Math.max(0, pulseWindowT - dt);
        if (pulseWindowT === 0) pulseCount = 0;
      }

      if (rising) {
        if (pulseWindowT === 0) {
          pulseWindowT = PULSE_WINDOW_S;
          pulseCount = 1;
        } else {
          pulseCount += 1;
        }

        if (pulseCount >= 3) {
          pulseCount = 0;
          pulseWindowT = 0;

          if (!world.started && !world.over) startGame();
          else if (world.over) startGame();
        }
      }
    }

    let dpr = 1;
    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = Math.max(320, Math.round(rect.width * dpr));
      const h = Math.max(240, Math.round(rect.height * dpr));

      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      if (renderCanvas.width !== w || renderCanvas.height !== h) {
        renderCanvas.width = w;
        renderCanvas.height = h;
      }
      if (distortCanvas.width !== w || distortCanvas.height !== h) {
        distortCanvas.width = w;
        distortCanvas.height = h;
      }

      return { w, h };
    }

    function presentWithBarrel(w, h) {
      if (!BARREL_ENABLED || BARREL_K <= 0) {
        viewCtx.setTransform(1, 0, 0, 1, 0, 0);
        viewCtx.clearRect(0, 0, w, h);
        viewCtx.drawImage(renderCanvas, 0, 0);
        return;
      }

      const K = BARREL_K;
      const slices = clamp(Math.round(BARREL_SLICES * (w / (900 * dpr))), 50, 140);

      const cx = w * 0.5;
      const cy = h * 0.5;
      const invCx = 1 / Math.max(1e-6, cx);
      const invCy = 1 / Math.max(1e-6, cy);

      dctx.setTransform(1, 0, 0, 1, 0, 0);
      dctx.clearRect(0, 0, w, h);

      const dx = w / slices;
      for (let i = 0; i < slices; i++) {
        const x0 = i * dx;
        const x1 = (i + 1) * dx;
        const xMid = (x0 + x1) * 0.5;

        const xNorm = (xMid - cx) * invCx;
        const s = 1 + K * (xNorm * xNorm);
        const invS = 1 / s;

        dctx.save();
        dctx.beginPath();
        dctx.rect(x0, 0, x1 - x0 + 0.5, h);
        dctx.clip();

        dctx.translate(0, cy);
        dctx.scale(1, invS);
        dctx.translate(0, -cy);

        dctx.drawImage(renderCanvas, 0, 0);
        dctx.restore();
      }

      viewCtx.setTransform(1, 0, 0, 1, 0, 0);
      viewCtx.clearRect(0, 0, w, h);

      const dy = h / slices;
      for (let i = 0; i < slices; i++) {
        const y0 = i * dy;
        const y1 = (i + 1) * dy;
        const yMid = (y0 + y1) * 0.5;

        const yNorm = (yMid - cy) * invCy;
        const s = 1 + K * (yNorm * yNorm);
        const invS = 1 / s;

        viewCtx.save();
        viewCtx.beginPath();
        viewCtx.rect(0, y0, w, y1 - y0 + 0.5);
        viewCtx.clip();

        viewCtx.translate(cx, 0);
        viewCtx.scale(invS, 1);
        viewCtx.translate(-cx, 0);

        viewCtx.drawImage(distortCanvas, 0, 0);
        viewCtx.restore();
      }
    }

    const player = { x: 0, y: 0, vy: 0, tilt: 0 };

    const world = {
      started: false,
      over: false,
      survive: 0,
      playT: 0,
      baseSpeed: 180,
      speed: 180,
      groundPad: 22,
      topPad: 22,
      distAcc: 0,
      nextSpawnDist: 760,
      obstacles: [],
      nextRestAt: REST_EVERY_S,
      restPending: false,
      resting: false,
      returning: false,
      restT: 0,
      returnT: 0,
      restScale: 1,
      restUiAlpha: 0
    };

    const G = 2200;
    const K_BASE = 30;
    const K_BOOST = 1.2;
    const DAMP_BASE = 22;
    const VTERM = 2400;

    const G_FALL_SCALE_MIN = 0.02;
    const G_FALL_CC_MAX = 100;

    function updateHUD() {
      hudTime.textContent = `Time: ${world.survive.toFixed(1)} s`;
      hudSpeed.textContent = `Speed: ${world.speed.toFixed(0)}`;
    }

    function resetGame() {
      const { w, h } = resizeCanvasToDisplaySize();

      world.started = false;
      world.over = false;

      world.survive = 0;
      world.playT = 0;

      world.speed = world.baseSpeed;

      world.distAcc = 0;
      world.obstacles = [];
      world.nextSpawnDist = 620;

      world.nextRestAt = REST_EVERY_S;
      world.restPending = false;
      world.resting = false;
      world.returning = false;
      world.restT = 0;
      world.returnT = 0;
      world.restScale = 1;
      world.restUiAlpha = 0;

      player.x = Math.round(w * 0.22);
      player.y = Math.round(h * 0.50);
      player.vy = 0;
      player.tilt = 0;

      tailVyFilt = 0;

      resetPulses();

      overlay.style.display = 'grid';
      overlayTitle.textContent = 'Ready';
      overlayText.innerHTML = 'Start with <span class="kbd">three breath pulses</span>';
      updateHUD();
    }

    function startGame() {
      if (!currentInput) {
        overlay.style.display = 'grid';
        overlayTitle.textContent = 'Ventra required';
        overlayText.innerHTML = 'Plug in Ventra, refresh, then start with <span class="kbd">three breath pulses</span>.';
        return;
      }
      if (world.over) resetGame();
      world.started = true;
      world.over = false;
      overlay.style.display = 'none';
      resetPulses();
      startMusicIfArmed();
    }

    function gameOver() {
      world.over = true;
      world.started = false;
      overlay.style.display = 'grid';
      overlayTitle.textContent = 'Game over';
      overlayText.innerHTML =
        `Survived: <span class="kbd">${world.survive.toFixed(1)} s</span>. ` +
        `Restart with <span class="kbd">three breath pulses</span>.`;
      resetPulses();
      stopMusic();

      world.restPending = false;
      world.resting = false;
      world.returning = false;
      world.restT = 0;
      world.returnT = 0;
      world.restScale = 1;
      world.restUiAlpha = 0;
    }

    function spawnObstacle(w, h) {
      const groundY = h - world.groundPad;
      const ceilingY = world.topPad;

      const gap = 150;
      const kind = (Math.random() < 0.55) ? 'pipe' : 'block';
      const vx = world.speed * dpr;

      if (kind === 'pipe') {
        const pipeW = 56 * dpr;
        const gapCentreMin = ceilingY + 90 * dpr;
        const gapCentreMax = groundY - 90 * dpr;
        const gapCentre = clamp(
          Math.round(gapCentreMin + Math.random() * (gapCentreMax - gapCentreMin)),
          gapCentreMin, gapCentreMax
        );

        const topH = Math.max(20 * dpr, Math.round((gapCentre - (gap * dpr) / 2) - ceilingY));
        const botY = Math.round(gapCentre + (gap * dpr) / 2);
        const botH = Math.max(20 * dpr, Math.round(groundY - botY));

        world.obstacles.push({
          kind: 'pipe',
          x: w + 20 * dpr,
          w: pipeW,
          vx,
          top: { y: ceilingY, w: pipeW, h: topH },
          bot: { y: botY,     w: pipeW, h: botH }
        });
      } else {
        const blockW = Math.round((46 + Math.random() * 46) * dpr);
        const blockH = Math.round((50 + Math.random() * 140) * dpr);
        world.obstacles.push({
          kind: 'block',
          x: w + 20 * dpr,
          y: groundY - blockH,
          w: blockW,
          h: blockH,
          vx
        });
      }
    }

    function ellipseRectHit(cx, cy, a, b, theta, rx, ry, rw, rh) {
      const cosT = Math.cos(-theta);
      const sinT = Math.sin(-theta);

      function toEllipseSpace(x, y) {
        const dx = x - cx;
        const dy = y - cy;
        const ex = dx * cosT - dy * sinT;
        const ey = dx * sinT + dy * cosT;
        return { x: ex, y: ey };
      }
      function insideEllipse(ex, ey) {
        const nx = ex / a;
        const ny = ey / b;
        return (nx * nx + ny * ny) <= 1;
      }

      const corners = [
        [rx, ry],
        [rx + rw, ry],
        [rx, ry + rh],
        [rx + rw, ry + rh],
      ];
      for (const [x, y] of corners) {
        const p = toEllipseSpace(x, y);
        if (insideEllipse(p.x, p.y)) return true;
      }

      const closestX = clamp(cx, rx, rx + rw);
      const closestY = clamp(cy, ry, ry + rh);
      const q = toEllipseSpace(closestX, closestY);
      if (insideEllipse(q.x, q.y)) return true;

      const samplesPerEdge = 3;
      for (let i = 1; i <= samplesPerEdge; i++) {
        const t = i / (samplesPerEdge + 1);

        let sx = rx + t * rw, sy = ry;
        let p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx + t * rw; sy = ry + rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx; sy = ry + t * rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx + rw; sy = ry + t * rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;
      }

      return false;
    }

    function cssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function drawEllipseDebug(cx, cy, a, b, theta) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(theta);

      ctx.globalAlpha = 0.18;
      ctx.fillStyle = DEBUG_COLL_COLOUR;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2 * dpr;
      ctx.strokeStyle = DEBUG_COLL_COLOUR;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(-a, 0);
      ctx.lineTo(a, 0);
      ctx.stroke();

      ctx.restore();
    }

    function drawCrtOverlayIntoScene(w, h) {
      const pat = ensureCrtPattern(w, h, dpr);
      if (!pat) return;

      ctx.save();

      // Approximate CSS filter: contrast() brightness()
      ctx.filter = `contrast(${CRT_CONTRAST}) brightness(${CRT_BRIGHTNESS})`;

      // Blend mode approximation (browser support varies; if unsupported it falls back)
      ctx.globalCompositeOperation = CRT_COMPOSITE;

      ctx.globalAlpha = CRT_OPACITY;
      ctx.fillStyle = pat;

      // Align pattern to pixel grid (reduce shimmer)
      ctx.translate(0.5 * dpr, 0.5 * dpr);
      ctx.fillRect(-0.5 * dpr, -0.5 * dpr, w + dpr, h + dpr);

      ctx.restore();

      // Reset (safety)
      ctx.filter = 'none';
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }

    function drawScene(w, h) {
      ctx.clearRect(0, 0, w, h);

      const groundY = h - world.groundPad;

      const border = cssVar('--border');
      const accentA = cssVar('--accentA');
      const accentB = cssVar('--accentB');
      const text = cssVar('--text');
      const muted = cssVar('--muted');

      // Ground
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = border;
      ctx.lineWidth = 2 * dpr;
      ctx.beginPath();
      ctx.moveTo(0, groundY + 1);
      ctx.lineTo(w, groundY + 1);
      ctx.stroke();
      ctx.restore();

      // Obstacles
      for (const ob of world.obstacles) {
        if (ob.kind === 'pipe') {
          ctx.fillStyle = accentA;
          ctx.fillRect(ob.x, ob.top.y, ob.top.w, ob.top.h);
          ctx.fillStyle = accentB;
          ctx.fillRect(ob.x, ob.bot.y, ob.bot.w, ob.bot.h);

          ctx.strokeStyle = border;
          ctx.lineWidth = 1 * dpr;
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.top.y + 0.5 * dpr, ob.top.w - 1 * dpr, ob.top.h - 1 * dpr);
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.bot.y + 0.5 * dpr, ob.bot.w - 1 * dpr, ob.bot.h - 1 * dpr);
        } else {
          ctx.fillStyle = accentA;
          ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
          ctx.strokeStyle = border;
          ctx.lineWidth = 1 * dpr;
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.y + 0.5 * dpr, ob.w - 1 * dpr, ob.h - 1 * dpr);
        }
      }

      // Player
      const drawW = MONKEY_DRAW_W * dpr;
      const drawH = MONKEY_DRAW_H * dpr;

      if (monkeyReady) {
        const s = (world.resting || world.returning) ? world.restScale : 1;
        drawMonkeyNeon(player.x, player.y, player.tilt, drawW, drawH, s);
      } else {
        ctx.save();
        ctx.fillStyle = text;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 14 * dpr, 0, Math.PI * 2);
        ctx.fill();

        const pct = cc2 / 127;
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = (pct > 0.01) ? cssVar('--warn') : muted;
        ctx.beginPath();
        ctx.arc(player.x, player.y, Math.max(3 * dpr, Math.round(14 * dpr * (0.25 + 0.35 * pct))), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // CRT overlay is part of the scene (so it gets barrel distortion)
      drawCrtOverlayIntoScene(w, h);

      // Breath phase overlay + 3-count (fades during fly-back)
      if (world.started && (world.resting || world.returning)) {
        const aUi = clamp(world.restUiAlpha, 0, 1);
        if (aUi > 0) {
          ctx.save();
          ctx.globalAlpha = REST_DIM_ALPHA * aUi;
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, w, h);
          ctx.restore();

          const dur = restDurationS();
          const u = clamp(world.restT / Math.max(1e-6, dur), 0, 1);
          const stepU = 1 / REST_COUNT;
          const idx = clamp(Math.floor(u / stepU), 0, REST_COUNT - 1);
          const countVal = Math.max(1, REST_COUNT - idx);

          ctx.save();
          ctx.globalAlpha = 0.92 * aUi;
          ctx.fillStyle = text;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          ctx.font = `${Math.round(18 * dpr)}px Orbitron, system-ui, sans-serif`;
          ctx.fillText('Breathe', Math.round(w * 0.5), Math.round(h * 0.42));

          ctx.font = `${Math.round(30 * dpr)}px Orbitron, system-ui, sans-serif`;
          ctx.fillText(String(countVal), Math.round(w * 0.5), Math.round(h * 0.50));

          ctx.font = `${Math.round(12 * dpr)}px "JetBrains Mono", ui-monospace, monospace`;
          ctx.globalAlpha = 0.78 * aUi;
          ctx.fillText('Control paused', Math.round(w * 0.5), Math.round(h * 0.58));
          ctx.restore();
        }
      }

      if (world.started && world.restPending && !world.resting && !world.returning) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = text;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.font = `${Math.round(11 * dpr)}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.fillText('Clearing…', Math.round(w - 10 * dpr), Math.round(h - 10 * dpr));
        ctx.restore();
      }

      if (SHOW_COLLISION_DEBUG) {
        const a = Math.max(8 * dpr, (drawW * COLL_A_FRAC));
        const b = Math.max(6 * dpr, (drawH * COLL_B_FRAC));
        const theta = COLL_ROT + (COLL_FOLLOWS_SPRITE_TILT ? player.tilt : 0);

        const cx = player.x + (drawW * COLL_CX_OFF_FRAC);
        const cy = player.y + (drawH * COLL_CY_OFF_FRAC);

        drawEllipseDebug(cx, cy, a, b, theta);
      }
    }

    let lastTs = 0;
    function step(ts) {
      const { w, h } = resizeCanvasToDisplaySize();

      const dt = Math.min(0.033, Math.max(0.001, (ts - (lastTs || ts)) / 1000));
      lastTs = ts;

      if (!currentInput) {
        setCC2(0);
        if (world.started) {
          world.started = false;
          world.over = false;
          overlay.style.display = 'grid';
          overlayTitle.textContent = 'Ventra required';
          overlayText.innerHTML = 'Plug in Ventra, refresh, then start with <span class="kbd">three breath pulses</span>.';
          stopMusic();
          resetPulses();
          tailVyFilt = 0;

          world.restPending = false;
          world.resting = false;
          world.returning = false;
          world.restT = 0;
          world.returnT = 0;
          world.restScale = 1;
          world.restUiAlpha = 0;
        }
      }

      registerPulse(dt);

      const groundY = h - world.groundPad;
      const ceilingY = world.topPad;

      if (world.started && !world.over) {
        const inBreak = (world.resting || world.returning);

        world.survive += dt;
        if (!inBreak) world.playT += dt;

        const targetSpeed = world.baseSpeed + SPEED_RAMP_PER_S * world.playT;
        world.speed = expApproach(world.speed, targetSpeed, dt, SPEED_TAU_S);

        if (!world.restPending && !inBreak && world.playT >= world.nextRestAt) {
          world.restPending = true;
        }

        for (const ob of world.obstacles) {
          const vx = (typeof ob.vx === 'number') ? ob.vx : (world.speed * dpr);
          ob.x -= vx * dt;
        }

        while (world.obstacles.length && (world.obstacles[0].x + (world.obstacles[0].w || world.obstacles[0].top.w)) < -40 * dpr) {
          world.obstacles.shift();
        }

        if (world.restPending && !inBreak && world.obstacles.length === 0) {
          world.restPending = false;
          world.resting = true;
          world.returning = false;
          world.restT = 0;
          world.returnT = 0;
          world.restScale = REST_FLYIN_SCALE_FROM;
          world.restUiAlpha = 1;
          world.distAcc = 0;
          player.vy = 0;
          player.tilt = 0;
          tailVyFilt = 0;
        }

        if (world.resting) {
          world.restT += dt;

          const dur = restDurationS();
          const u = clamp(world.restT / Math.max(1e-6, dur), 0, 1);

          const centreX = Math.round(w * REST_CENTRE_X_FRAC);
          const centreY = Math.round(h * REST_CENTRE_Y_FRAC);

          player.x = expApproach(player.x, centreX, dt, REST_MOVE_TAU_S);
          player.y = expApproach(player.y, centreY, dt, REST_MOVE_TAU_S);

          player.vy = 0;
          player.tilt = 0;

          const flyU = clamp(u / Math.max(1e-6, REST_FLYIN_FRACTION), 0, 1);
          const baseScale = REST_FLYIN_SCALE_FROM + (REST_BASE_SCALE - REST_FLYIN_SCALE_FROM) * flyU;

          const phase = u * REST_PULSES * Math.PI * 2;
          const pulse01 = 0.5 - 0.5 * Math.cos(phase);
          world.restScale = baseScale * (1 + REST_PULSE_SCALE * pulse01);

          tailVyFilt = expApproach(tailVyFilt, 0, dt, 0.06);

          if (world.restT >= dur) {
            world.restT = dur;
            world.resting = false;
            world.returning = true;
            world.returnT = 0;
            world.restUiAlpha = 1;

            player.vy = 0;
            player.tilt = 0;
            tailVyFilt = 0;

            world.nextRestAt += REST_EVERY_S;
          }
        }

        if (world.returning) {
          world.returnT += dt;

          const dur = restDurationS();
          const returnS = Math.max(0.05, dur * REST_RETURN_FRACTION);

          const laneX = Math.round(w * 0.22);
          const centreY = Math.round(h * REST_CENTRE_Y_FRAC);

          world.restUiAlpha = clamp(1 - (world.returnT / Math.max(1e-6, REST_UI_FADE_S)), 0, 1);

          player.x = expApproach(player.x, laneX, dt, REST_RETURN_TAU_S);
          player.y = expApproach(player.y, centreY, dt, REST_RETURN_TAU_S);

          world.restScale = expApproach(world.restScale, 1, dt, REST_RETURN_TAU_S);

          player.vy = 0;
          player.tilt = 0;
          tailVyFilt = expApproach(tailVyFilt, 0, dt, 0.06);

          if (world.returnT >= returnS) {
            world.returning = false;
            world.returnT = 0;
            world.restUiAlpha = 0;
            world.restScale = 1;

            player.x = laneX;
            player.vy = 0;
            player.tilt = 0;
            tailVyFilt = 0;

            world.distAcc = 0;
          }
        }

        if (!world.resting && !world.returning) {
          const pct = cc2 / 127;
          const maxLift = (groundY - 14 * dpr) - (ceilingY + 14 * dpr);
          const targetY = (groundY - 14 * dpr) - (pct * maxLift);

          const speedFactor = clamp(world.speed / world.baseSpeed, 1, 3.2);
          const K = K_BASE * (1 + K_BOOST * (speedFactor - 1));
          const DAMP = DAMP_BASE * (0.95 + 0.25 * (speedFactor - 1));

          const speedFade = clamp((speedFactor - 1) / (3.2 - 1), 0, 1);
          const ccFade = clamp(cc2 / G_FALL_CC_MAX, 0, 1);
          const fallScale = (G_FALL_SCALE_MIN + (1 - G_FALL_SCALE_MIN) * ccFade);
          const gEff = G * (fallScale + (1 - fallScale) * speedFade);

          let ay = (K * (targetY - player.y)) - (DAMP * player.vy) + gEff;

          player.vy += ay * dt;
          player.vy = clamp(player.vy, -VTERM * dpr, VTERM * dpr);
          player.y += player.vy * dt;

          {
            const alpha = 1 - Math.exp(-dt / Math.max(1e-6, TAIL_VY_TAU_S));
            tailVyFilt = tailVyFilt + alpha * (player.vy - tailVyFilt);
          }

          player.tilt = clamp(-player.vy / (900 * dpr), -0.20, 0.20);

          const floorY = groundY - 14 * dpr;
          if (player.y > floorY) { player.y = floorY; if (player.vy > 0) player.vy = 0; }
          const ceilY = ceilingY + 14 * dpr;
          if (player.y < ceilY) { player.y = ceilY; if (player.vy < 0) player.vy = 0; }

          const t = world.playT;
          const startMean = 760 * dpr;
          const endMean = 560 * dpr;
          const ease = clamp(t / 18, 0, 1);
          const mean = startMean + (endMean - startMean) * ease;
          const jitter = 0.18;

          world.distAcc += (world.speed * dpr) * dt;

          if (!world.restPending) {
            if (world.distAcc >= world.nextSpawnDist) {
              world.distAcc = 0;
              spawnObstacle(w, h);
              const r = (Math.random() * 2 - 1) * jitter;
              world.nextSpawnDist = Math.max(420 * dpr, mean * (1 + r));
            }
          } else {
            world.distAcc = Math.min(world.distAcc, world.nextSpawnDist - 0.001);
          }

          const drawW = MONKEY_DRAW_W * dpr;
          const drawH = MONKEY_DRAW_H * dpr;
          const a = Math.max(8 * dpr, (drawW * COLL_A_FRAC));
          const b = Math.max(6 * dpr, (drawH * COLL_B_FRAC));
          const collTheta = COLL_ROT + (COLL_FOLLOWS_SPRITE_TILT ? player.tilt : 0);

          const cx = player.x + (drawW * COLL_CX_OFF_FRAC);
          const cy = player.y + (drawH * COLL_CY_OFF_FRAC);

          for (const ob of world.obstacles) {
            if (ob.kind === 'pipe') {
              if (
                ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.top.y, ob.top.w, ob.top.h) ||
                ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.bot.y, ob.bot.w, ob.bot.h)
              ) { gameOver(); break; }
            } else {
              if (ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.y, ob.w, ob.h)) {
                gameOver(); break;
              }
            }
          }
        }
      } else {
        player.tilt = 0;
        tailVyFilt *= 0.90;
        world.restScale = 1;
        world.restUiAlpha = 0;
      }

      updateHUD();

      // Scene -> offscreen (includes CRT), then barrel -> onscreen
      drawScene(w, h);
      presentWithBarrel(w, h);

      requestAnimationFrame(step);
    }

    function onMIDIMessage(e) {
      const data = e.data;
      if (!data || data.length < 3) return;

      const status = data[0];
      const type = status & 0xF0;

      const targetStatus = 0xB0 | ((targetChannel1Based - 1) & 0x0F);
      if (type === 0xB0 && status === targetStatus && data[1] === targetCC) {
        setCC2(data[2]);
      }
    }

    const helpBtn = document.getElementById('helpBtn');
    const helpDialog = document.getElementById('helpDialog');
    const closeHelp = document.getElementById('closeHelp');

    helpBtn.addEventListener('click', () => { helpDialog.showModal(); });
    closeHelp.addEventListener('click', () => { helpDialog.close(); });

    helpDialog.addEventListener('click', (e) => {
      const rect = helpDialog.getBoundingClientRect();
      const inside =
        e.clientX >= rect.left &&
        e.clientX <= rect.right &&
        e.clientY >= rect.top &&
        e.clientY <= rect.bottom;
      if (!inside) helpDialog.close();
    });

    resetGame();
    setCC2(0);
    requestAnimationFrame(step);
  </script>
</body>
</html>
