<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EXHALE//ASCEND</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;800;900&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root { color-scheme: dark; }

    :root{
      --bg:#000000;
      --text:#EDF4FA;
      --muted:#9AA4B2;
      --accentA:#8B5CF6;
      --accentB:#EC4899;
      --warn:#FFB86B;
      --danger:#FF6B6B;
      --border:#262C3C;

      /* Rounded corner control (CSS px) */
      --screen-radius-px: 0px;
    }

    html, body { height: 100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      line-height:1.35;
      display:grid;
      place-items:center;
      overflow:hidden;
    }

    /* Single visible element: the canvas area. Outside stays pure black. */
    .gameShell{
      position:relative;
      width:min(98vw, 1100px);
      aspect-ratio: 4 / 3;
      max-height: 95vh;
      background:#000;

      /* Rounded corners (clips the canvas) */
      border-radius: var(--screen-radius-px);
      overflow:hidden;
    }

    canvas{
      display:block;
      width:100%;
      height:100%;
      background:#000;
      cursor:default;
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;

      /* Keep canvas edges aligned with shell rounding */
      border-radius: var(--screen-radius-px);
    }
  </style>
</head>

<body>
  <div class="gameShell" id="gameShell" aria-label="Ventra game">
    <canvas id="game"></canvas>
  </div>

  <audio id="bgm" loop preload="auto">
    <source src="./music.ogg" type="audio/ogg">
    <source src="./music.mp3" type="audio/mpeg">
  </audio>

  <script>
    'use strict';

    let nowS = 0;

    function clamp(n, lo, hi) { return Math.min(hi, Math.max(lo, n)); }

    function expApproach(current, target, dt, tau) {
      const a = 1 - Math.exp(-dt / Math.max(1e-6, tau));
      return current + (target - current) * a;
    }

    const SHOW_COLLISION_DEBUG = false;
    const COLL_FOLLOWS_SPRITE_TILT = true;
    const DEBUG_COLL_COLOUR = '#00FFFF';

    // ============================================================
    // Screen presentation (rounded corners)
    // ============================================================
    // CSS pixels; applied to --screen-radius-px.
    const SCREEN_CORNER_RADIUS_PX = 70;

    // ============================================================
    // Barrel distortion (lens bulge)
    // ============================================================
    const BARREL_ENABLED = true;
    const BARREL_K = 0.075;
    const BARREL_SLICES = 128;

    // Approx inverse mapping for click hit-testing (good enough for UI).
    function viewToScene(xv, yv, w, h) {
      if (!BARREL_ENABLED || BARREL_K <= 0) return { x: xv, y: yv };

      const K = BARREL_K;
      const cx = w * 0.5;
      const cy = h * 0.5;

      // Invert second pass (x scaled by invS(y))
      const yNorm = (yv - cy) / Math.max(1e-6, cy);
      const Sy = 1 + K * (yNorm * yNorm);
      const xs = cx + (xv - cx) * Sy;

      // Invert first pass (y scaled by invS(x))
      const xNorm = (xs - cx) / Math.max(1e-6, cx);
      const Sx = 1 + K * (xNorm * xNorm);
      const ys = cy + (yv - cy) * Sx;

      return { x: xs, y: ys };
    }

    // ============================================================
    // CRT (rendered into the off-screen scene, so it gets barrel distortion)
    // ============================================================
    const CRT_OPACITY = 0.12;
    const CRT_REPEATS_X = 120;
    const CRT_BRICK_OFFSET_FRAC = 1/2;

    const CRT_COMPOSITE = 'soft-light';   // browser-dependent support
    const CRT_CONTRAST = 0.8;
    const CRT_BRIGHTNESS = 0.40;

    const crtImg = new Image();
    let crtImgReady = false;
    crtImg.onload = () => { crtImgReady = true; };
    crtImg.onerror = (e) => { console.warn('Failed to load overlay-pattern.png', e); };
    crtImg.src = './overlay-pattern.png';

    let crtPattern = null;
    let crtPatternTilePx = 0;
    let crtPatternShiftPx = -1;

    // ============================================================
    // Film grain / noise layer (drawn on top of the scene)
    // ============================================================
    const NOISE_ENABLED = true;
    const NOISE_ALPHA = 0.04;          // 0..1 (primary intensity control)
    const NOISE_COMPOSITE = 'overlay'; // 'overlay'/'soft-light'/'source-over'
    const NOISE_TILE_PX = 512;         // CSS px-ish target; actual is scaled by dpr
    const NOISE_UPDATE_HZ = 24;        // how often noise regenerates (per second)

    const noiseCanvas = document.createElement('canvas');
    const nctx = noiseCanvas.getContext('2d');
    let noisePattern = null;
    let noiseLastW = 0;
    let noiseLastH = 0;
    let noiseLastUpdateT = 0;
    let noiseSeed = 1337;

    function lcgRand() {
      // Deterministic small PRNG (fast, stable across browsers).
      noiseSeed = (noiseSeed * 1664525 + 1013904223) >>> 0;
      return noiseSeed / 4294967296;
    }

    function ensureNoisePattern(w, h, dprLocal, tsSeconds) {
      if (!NOISE_ENABLED || NOISE_ALPHA <= 0) return null;

      // Keep a roughly constant grain size in CSS px by scaling with dpr.
      const tilePx = Math.max(64, Math.round(NOISE_TILE_PX * dprLocal));
      const needsResize = (noiseCanvas.width !== tilePx || noiseCanvas.height !== tilePx);

      const updateInterval = 1 / Math.max(1, NOISE_UPDATE_HZ);
      const needsUpdate = (tsSeconds - noiseLastUpdateT) >= updateInterval;

      if (needsResize) {
        noiseCanvas.width = tilePx;
        noiseCanvas.height = tilePx;
        noisePattern = null;
      }

      if (needsResize || needsUpdate || !noisePattern || w !== noiseLastW || h !== noiseLastH) {
        // Regenerate pixels.
        const img = nctx.createImageData(noiseCanvas.width, noiseCanvas.height);
        const data = img.data;

        // Subtle grain: biased towards midtones.
        for (let i = 0; i < data.length; i += 4) {
          // Triangular distribution around ~0.5 for softer grain
          const r = (lcgRand() + lcgRand()) * 0.5;     // 0..1
          const v = Math.floor(255 * r);
          data[i + 0] = v;
          data[i + 1] = v;
          data[i + 2] = v;
          data[i + 3] = 255;
        }

        nctx.putImageData(img, 0, 0);

        // Pattern can be created from the main scene ctx later; store canvas only here.
        noiseLastUpdateT = tsSeconds;
        noiseLastW = w;
        noiseLastH = h;
        noisePattern = null; // force re-create on scene ctx
      }

      return noiseCanvas;
    }

    function drawFilmGrain(w, h, tsSeconds) {
      if (!NOISE_ENABLED || NOISE_ALPHA <= 0) return;

      const src = ensureNoisePattern(w, h, dpr, tsSeconds);
      if (!src) return;

      // Pattern must be created on the destination context (ctx).
      if (!noisePattern) noisePattern = ctx.createPattern(src, 'repeat');
      if (!noisePattern) return;

      ctx.save();
      ctx.globalAlpha = NOISE_ALPHA;
      ctx.globalCompositeOperation = NOISE_COMPOSITE;

      // Avoid smoothing so grain stays crisp.
      ctx.imageSmoothingEnabled = false;

      // Slight drift to avoid static pattern feel (cheap motion).
      const drift = (tsSeconds * 23.0) % (src.width || 1);
      ctx.translate(-drift, -drift);

      ctx.fillStyle = noisePattern;
      ctx.fillRect(drift, drift, w + src.width, h + src.height);

      ctx.restore();

      ctx.imageSmoothingEnabled = true;
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }

    // ============================================================
    // Assets
    // ============================================================
    const monkeyImg = new Image();
    let monkeyReady = false;
    monkeyImg.onload = () => { monkeyReady = true; };
    monkeyImg.onerror = (e) => { console.warn('Failed to load monkey.svg', e); };
    monkeyImg.src = './monkey.svg';

    const MONKEY_DRAW_W = 150;
    const MONKEY_DRAW_H = 150;

    const MONKEY_BASE_STROKE_PX = 4;
    const MONKEY_GOLD_STROKE_PX = 4;
    const MONKEY_RED_STROKE_PX  = 4;
    const MONKEY_BLUE_STROKE_PX = 6;
    const MONKEY_AQUA_STROKE_PX = 6;

    const MONKEY_BASE_COLOUR = '#FFFFFF';
    const MONKEY_GOLD_COLOUR = '#FFCC33';
    const MONKEY_RED_COLOUR  = '#69003a';
    const MONKEY_BLUE_COLOUR = '#00A3FF';
    const MONKEY_AQUA_COLOUR = '#00FFFF';

    const MONKEY_BASE_ALPHA = 0.6;
    const MONKEY_GLOW_ALPHA = 1;
    const MONKEY_AURA_ALPHA = 0.7;
    const MONKEY_BASE_PASSES = 2;

    const MONKEY_GLOW_BLUR_PX = 1.25;
    const MONKEY_AURA_BLUR_PX = 8;

    const MONKEY_GOLD_OFF_CSS = { x: -0,  y: 4 };
    const MONKEY_RED_OFF_CSS  = { x: -4,  y: 0 };
    const MONKEY_BLUE_OFF_CSS = { x: 4,   y: 0 };
    const MONKEY_AQUA_OFF_CSS = { x: 0,   y: 0 };

    const TAIL_X_CAP_S = 60;
    const TAIL_X_MAX_CSS = 18;
    const TAIL_Y_MAX_CSS = 20;
    const TAIL_VY_FOR_MAX = 1200;
    const TAIL_VY_TAU_S = 0.10;
    const TAIL_SCALE_MAX = 0.08;

    let tailVyFilt = 0;

    const monkeyMaskCanvas  = document.createElement('canvas');
    const monkeyLayerCanvas = document.createElement('canvas');
    let monkeyCacheW = 0;
    let monkeyCacheH = 0;

    // ============================================================
    // Rest / pause settings (unchanged)
    // ============================================================
    const REST_EVERY_S = 25;
    const REST_COUNT = 3;
    const REST_COUNT_STEP_S = 1.75;
    const REST_PULSES = 3;

    const REST_FLYIN_SCALE_FROM = 1.00;
    const REST_BASE_SCALE = 1.50;
    const REST_PULSE_SCALE = 0.10;

    const REST_DIM_ALPHA = 0.18;
    const REST_MOVE_TAU_S = 0.22;
    const REST_RETURN_TAU_S = 0.18;

    const REST_CENTRE_X_FRAC = 0.50;
    const REST_CENTRE_Y_FRAC = 0.50;

    const REST_FLYIN_FRACTION = 0.55;
    const REST_RETURN_FRACTION = 0.25;
    const REST_UI_FADE_S = 0.25;

    function restDurationS() {
      return Math.max(0.2, REST_COUNT * REST_COUNT_STEP_S);
    }

    const SPEED_RAMP_PER_S = 14;
    const SPEED_TAU_S = 0.60;
    // If true, prevent world.speed from drifting upward during rest/return phases.
    const FREEZE_SPEED_DURING_REST = true;

    // After each rest cycle completes, reduce the ramp time slightly (seconds).
    // This lowers targetSpeed after a pause without resetting difficulty.
    const POST_REST_PLAYT_REWIND_S = 1.25; // try 0.5..2.5

    // ============================================================
    // MIDI
    // ============================================================
    const targetChannel1Based = 1;
    const targetCC = 2;

    let midiAccess = null;
    let currentInput = null;

    function detachCurrentInput() {
      if (currentInput) currentInput.onmidimessage = null;
      currentInput = null;
    }

    function isVentraPort(p) {
      const name = (p && p.name ? String(p.name) : '').toLowerCase();
      const manu = (p && p.manufacturer ? String(p.manufacturer) : '').toLowerCase();
      return name.includes('ventra') || manu.includes('ventra');
    }

    function findVentraInput() {
      if (!midiAccess) return null;
      const inputs = Array.from(midiAccess.inputs.values());
      return inputs.find(isVentraPort) || null;
    }

    function attachVentraIfPresent() {
      detachCurrentInput();
      const input = findVentraInput();
      if (!input) return false;
      currentInput = input;
      currentInput.onmidimessage = onMIDIMessage;
      return true;
    }

    async function initMIDI() {
      if (!('requestMIDIAccess' in navigator)) return;
      try {
        midiAccess = await navigator.requestMIDIAccess({ sysex: false });
        attachVentraIfPresent();
        midiAccess.onstatechange = () => attachVentraIfPresent();
      } catch (err) {
        console.error(err);
      }
    }

    initMIDI();

    // ============================================================
    // Audio (same behaviour as before: stored pref; autoplay may block until interaction)
    // ============================================================
    const bgm = document.getElementById('bgm');
    const AUDIO_KEY = 'ventra_game_music';
    let audioOn = true;

    function loadAudioPref() {
      const saved = localStorage.getItem(AUDIO_KEY);
      audioOn = (saved === null) ? true : (saved === '1');
      if (saved === null) localStorage.setItem(AUDIO_KEY, '1');
    }
    loadAudioPref();

    function musicIsArmed() { return audioOn; }

    async function startMusicIfArmed() {
      if (!bgm) return;
      if (!musicIsArmed()) return;

      // Ensure WebAudio graph exists (safe if already built).
      // This must be called from a user gesture for best reliability.
      try { await ensureAudioFX(); } catch (e) { console.warn(e); }

      try { await bgm.play(); }
      catch (e) { /* autoplay blocks are expected */ }
    }

    function stopMusic() {
      if (!bgm) return;
      bgm.pause();
      bgm.currentTime = 0;
    }

    function setAudio(on) {
      audioOn = !!on;
      localStorage.setItem(AUDIO_KEY, audioOn ? '1' : '0');
      if (!audioOn) stopMusic();
      else if (world && world.started) startMusicIfArmed();
    }

    // ============================================================
    // Neo-retro master bus (WebAudio FX for <audio id="bgm">)
    // ============================================================

    // --- Tonal framing (authentic-ish bandwidth) ---
    const FX_HIGHPASS_HZ = 450;     // remove sub-rumble
    const FX_LOWPASS_HZ  = 8000;  // shave hi-fi sheen

    // --- Saturation (neo-retro "cabinet edge") ---
    const FX_SAT_DRIVE   = 0.12;   // 0..1-ish (soft)
    const FX_SAT_MIX     = 0.05;   // 0..1 (parallel saturation amount)

    // --- Glue compression (subtle) ---
    const FX_COMP_THRESH_DB = -22;
    const FX_COMP_RATIO     = 2.0;
    const FX_COMP_ATTACK_S  = 0.010;
    const FX_COMP_RELEASE_S = 0.140;
    const FX_COMP_KNEE_DB   = 12;

    // --- Short "digital plate-ish" reverb (tasteful) ---
    const FX_VERB_WET       = 0.6;   // 0..1 (keep small)
    const FX_VERB_DECAY_S   = 0.55;   // short tail
    const FX_VERB_HIGHPASS_HZ = 320;  // keep low-end clean
    const FX_VERB_LOWPASS_HZ  = 7500; // keep tail retro

    // --- Optional parallel bitcrush (neo texture) ---
    const FX_BITCRUSH_ENABLED   = true;
    const FX_BITCRUSH_WET       = 0.05;  // 0..1 (keep small)
    const FX_BITCRUSH_BITDEPTH  = 8;     // 6..12 typical
    const FX_BITCRUSH_REDUCE    = 0.8;  // 0..1 (more = more downsample)

    // --- Output ---
    const FX_MASTER_GAIN = 0.85;



    let audioCtx = null;
    let fx = null; // {src, inGain, hp, lp, satDry, satWet, satMix, comp, verbSend, verbWet, master, bitDry, bitWet, ...}

    function makeSoftClipCurve(drive = 0.5, n = 4096) {
      // Smooth-ish saturator curve (tanh-like) without heavy aliasing.
      const curve = new Float32Array(n);
      const k = 1 + 20 * clamp(drive, 0, 1); // scale
      for (let i = 0; i < n; i++) {
        const x = (i * 2) / (n - 1) - 1; // -1..1
        curve[i] = Math.tanh(k * x) / Math.tanh(k);
      }
      return curve;
    }

    function createImpulseResponse(ctxLocal, durationS, decay) {
      // Synthetic noise IR -> filtered later; small + cheap.
      const sr = ctxLocal.sampleRate;
      const len = Math.max(1, Math.floor(sr * durationS));
      const ir = ctxLocal.createBuffer(2, len, sr);

      for (let ch = 0; ch < 2; ch++) {
        const data = ir.getChannelData(ch);
        for (let i = 0; i < len; i++) {
          const t = i / sr;
          const env = Math.pow(1 - (i / len), decay); // exponential-ish
          data[i] = (Math.random() * 2 - 1) * env;
        }
      }
      return ir;
    }

    async function ensureAudioFX() {
      if (!bgm) return null;

      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }

      if (audioCtx.state === 'suspended') {
        // Must be called from a user gesture (click/tap).
        try { await audioCtx.resume(); } catch {}
      }

      if (fx) return fx;

      // MediaElementSource must be created once per <audio> element.
      const src = audioCtx.createMediaElementSource(bgm);

      // Input trim (optional, for headroom before saturation)
      const inGain = audioCtx.createGain();
      inGain.gain.value = 1.0;

      // Bandwidth framing
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = FX_HIGHPASS_HZ;
      hp.Q.value = 0.707;

      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = FX_LOWPASS_HZ;
      lp.Q.value = 0.707;

      // Parallel saturation
      const satDry = audioCtx.createGain();
      satDry.gain.value = 1.0;

      const satShaper = audioCtx.createWaveShaper();
      satShaper.curve = makeSoftClipCurve(FX_SAT_DRIVE);
      satShaper.oversample = '2x';

      const satWet = audioCtx.createGain();
      satWet.gain.value = 1.0;

      const satMix = audioCtx.createGain();
      satMix.gain.value = clamp(FX_SAT_MIX, 0, 1);

      const satDryToComp = audioCtx.createGain();
      satDryToComp.gain.value = 1.0 - clamp(FX_SAT_MIX, 0, 1);

      // Compressor (glue)
      const comp = audioCtx.createDynamicsCompressor();
      comp.threshold.value = FX_COMP_THRESH_DB;
      comp.ratio.value = FX_COMP_RATIO;
      comp.attack.value = FX_COMP_ATTACK_S;
      comp.release.value = FX_COMP_RELEASE_S;
      comp.knee.value = FX_COMP_KNEE_DB;

      // Reverb send (short, filtered)
      const verbSend = audioCtx.createGain();
      verbSend.gain.value = 1.0;

      const convolver = audioCtx.createConvolver();
      convolver.buffer = createImpulseResponse(audioCtx, FX_VERB_DECAY_S, 2.2);

      // Filter the reverb return to keep it "retro-clean"
      const verbHP = audioCtx.createBiquadFilter();
      verbHP.type = 'highpass';
      verbHP.frequency.value = FX_VERB_HIGHPASS_HZ;
      verbHP.Q.value = 0.707;

      const verbLP = audioCtx.createBiquadFilter();
      verbLP.type = 'lowpass';
      verbLP.frequency.value = FX_VERB_LOWPASS_HZ;
      verbLP.Q.value = 0.707;

      const verbWet = audioCtx.createGain();
      verbWet.gain.value = clamp(FX_VERB_WET, 0, 1);

      // Optional parallel bitcrush (AudioWorklet, inline module)
      let bitNode = null;
      let bitWet = null;
      let bitDry = null;

      if (FX_BITCRUSH_ENABLED && audioCtx.audioWorklet) {
        const workletCode = `
          class BitCrusher extends AudioWorkletProcessor {
            static get parameterDescriptors() {
              return [
                { name: 'bitDepth', defaultValue: 8, minValue: 2, maxValue: 16, automationRate: 'k-rate' },
                { name: 'reduce',   defaultValue: 0.4, minValue: 0, maxValue: 1,  automationRate: 'k-rate' }
              ];
            }
            constructor() {
              super();
              this._phase = 0;
              this._hold = 0;
            }
            process(inputs, outputs, parameters) {
              const input = inputs[0];
              const output = outputs[0];
              if (!input || input.length === 0) return true;

              const bd = parameters.bitDepth[0];
              const reduce = parameters.reduce[0];

              const step = Math.pow(0.5, bd);
              // reduction: 0 => no hold, 1 => max hold (lower effective sample-rate)
              const holdN = 1 + Math.floor(reduce * 40);

              for (let ch = 0; ch < input.length; ch++) {
                const inp = input[ch];
                const out = output[ch];
                for (let i = 0; i < inp.length; i++) {
                  this._phase++;
                  if (this._phase >= holdN) {
                    this._phase = 0;
                    // quantise sample amplitude
                    const x = inp[i];
                    this._hold = Math.round(x / step) * step;
                  }
                  out[i] = this._hold;
                }
              }
              return true;
            }
          }
          registerProcessor('bit-crusher', BitCrusher);
        `;
        const blob = new Blob([workletCode], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        try {
          await audioCtx.audioWorklet.addModule(url);
          bitNode = new AudioWorkletNode(audioCtx, 'bit-crusher');
          bitNode.parameters.get('bitDepth').value = FX_BITCRUSH_BITDEPTH;
          bitNode.parameters.get('reduce').value = FX_BITCRUSH_REDUCE;

          bitDry = audioCtx.createGain();
          bitDry.gain.value = 1.0 - clamp(FX_BITCRUSH_WET, 0, 1);

          bitWet = audioCtx.createGain();
          bitWet.gain.value = clamp(FX_BITCRUSH_WET, 0, 1);
        } catch (e) {
          console.warn('Bitcrush worklet unavailable; continuing without bitcrush.', e);
          bitNode = null;
        } finally {
          URL.revokeObjectURL(url);
        }
      }

      // Master
      const master = audioCtx.createGain();
      master.gain.value = FX_MASTER_GAIN;

      // ---------------------------
      // Wiring (graph)
      // ---------------------------

      // src -> inGain -> hp -> lp
      src.connect(inGain);
      inGain.connect(hp);
      hp.connect(lp);

      // Split for parallel saturation:
      // lp -> satDryToComp -> comp
      lp.connect(satDry);
      satDry.connect(satDryToComp);

      // lp -> satShaper -> satWet -> satMix -> comp
      lp.connect(satShaper);
      satShaper.connect(satWet);
      satWet.connect(satMix);

      // sum into comp
      satDryToComp.connect(comp);
      satMix.connect(comp);

      // Reverb send from pre-comp (more “retro”), and return mixed post-comp
      lp.connect(verbSend);
      verbSend.connect(convolver);
      convolver.connect(verbHP);
      verbHP.connect(verbLP);
      verbLP.connect(verbWet);

      // Post-comp summing: comp + verbWet -> (optional bitcrush parallel) -> master -> destination
      const postSum = audioCtx.createGain();
      postSum.gain.value = 1.0;

      comp.connect(postSum);
      verbWet.connect(postSum);

      if (bitNode && bitDry && bitWet) {
        // parallel bitcrush (postSum -> dry + crushed -> master)
        postSum.connect(bitDry);
        postSum.connect(bitNode);
        bitNode.connect(bitWet);

        bitDry.connect(master);
        bitWet.connect(master);
      } else {
        postSum.connect(master);
      }

      master.connect(audioCtx.destination);

      fx = {
        src,
        inGain, hp, lp,
        satShaper, satDryToComp, satMix,
        comp,
        verbSend, convolver, verbHP, verbLP, verbWet,
        postSum,
        bitNode, bitDry, bitWet,
        master
      };

      return fx;
    }

    // ============================================================
    // Canvas setup
    // ============================================================
    const gameShell = document.getElementById('gameShell');
    const canvas = document.getElementById('game');
    const viewCtx = canvas.getContext('2d', { alpha: true });

    const renderCanvas = document.createElement('canvas');
    const ctx = renderCanvas.getContext('2d');

    const distortCanvas = document.createElement('canvas');
    const dctx = distortCanvas.getContext('2d');

    let dpr = 1;

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      const w = Math.max(320, Math.round(rect.width * dpr));
      const h = Math.max(240, Math.round(rect.height * dpr));

      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      if (renderCanvas.width !== w || renderCanvas.height !== h) {
        renderCanvas.width = w;
        renderCanvas.height = h;
      }
      if (distortCanvas.width !== w || distortCanvas.height !== h) {
        distortCanvas.width = w;
        distortCanvas.height = h;
      }

      return { w, h };
    }

    // ============================================================
    // Barrel presentation (unchanged)
    // ============================================================
    function presentWithBarrel(w, h) {
      if (!BARREL_ENABLED || BARREL_K <= 0) {
        viewCtx.setTransform(1, 0, 0, 1, 0, 0);
        viewCtx.clearRect(0, 0, w, h);
        viewCtx.drawImage(renderCanvas, 0, 0);
        return;
      }

      const K = BARREL_K;
      const slices = clamp(Math.round(BARREL_SLICES * (w / (900 * dpr))), 50, 140);

      const cx = w * 0.5;
      const cy = h * 0.5;
      const invCx = 1 / Math.max(1e-6, cx);
      const invCy = 1 / Math.max(1e-6, cy);

      dctx.setTransform(1, 0, 0, 1, 0, 0);
      dctx.clearRect(0, 0, w, h);

      const dx = w / slices;
      for (let i = 0; i < slices; i++) {
        const x0 = i * dx;
        const x1 = (i + 1) * dx;
        const xMid = (x0 + x1) * 0.5;

        const xNorm = (xMid - cx) * invCx;
        const s = 1 + K * (xNorm * xNorm);
        const invS = 1 / s;

        dctx.save();
        dctx.beginPath();
        dctx.rect(x0, 0, x1 - x0 + 0.5, h);
        dctx.clip();

        dctx.translate(0, cy);
        dctx.scale(1, invS);
        dctx.translate(0, -cy);

        dctx.drawImage(renderCanvas, 0, 0);
        dctx.restore();
      }

      viewCtx.setTransform(1, 0, 0, 1, 0, 0);
      viewCtx.clearRect(0, 0, w, h);

      const dy = h / slices;
      for (let i = 0; i < slices; i++) {
        const y0 = i * dy;
        const y1 = (i + 1) * dy;
        const yMid = (y0 + y1) * 0.5;

        const yNorm = (yMid - cy) * invCy;
        const s = 1 + K * (yNorm * yNorm);
        const invS = 1 / s;

        viewCtx.save();
        viewCtx.beginPath();
        viewCtx.rect(0, y0, w, y1 - y0 + 0.5);
        viewCtx.clip();

        viewCtx.translate(cx, 0);
        viewCtx.scale(invS, 1);
        viewCtx.translate(-cx, 0);

        viewCtx.drawImage(distortCanvas, 0, 0);
        viewCtx.restore();
      }
    }

    // ============================================================
    // CRT pattern builder
    // ============================================================
    function ensureCrtPattern(w, h, dprLocal) {
      if (!crtImgReady) return null;

      const tileCssPx = Math.max(2, Math.round((w / dprLocal) / CRT_REPEATS_X));
      const shiftPx = Math.round(tileCssPx * CRT_BRICK_OFFSET_FRAC) % tileCssPx;

      if (crtPattern && tileCssPx === crtPatternTilePx && shiftPx === crtPatternShiftPx) return crtPattern;

      const tile = document.createElement('canvas');
      tile.width = tileCssPx;
      tile.height = tileCssPx;
      const tctx = tile.getContext('2d');
      tctx.clearRect(0, 0, tileCssPx, tileCssPx);
      tctx.drawImage(crtImg, 0, 0, tileCssPx, tileCssPx);

      const brick = document.createElement('canvas');
      brick.width = tileCssPx;
      brick.height = tileCssPx * 2;
      const bctx = brick.getContext('2d');
      bctx.clearRect(0, 0, brick.width, brick.height);
      bctx.drawImage(tile, 0, 0);
      bctx.drawImage(tile, -shiftPx, tileCssPx);
      bctx.drawImage(tile, tileCssPx - shiftPx, tileCssPx);

      const pat = ctx.createPattern(brick, 'repeat');
      crtPattern = pat;
      crtPatternTilePx = tileCssPx;
      crtPatternShiftPx = shiftPx;
      return pat;
    }

    function drawCrtOverlayIntoScene(w, h) {
      const pat = ensureCrtPattern(w, h, dpr);
      if (!pat) return;

      ctx.save();

      // Pattern blending + mild filtering
      ctx.filter = `contrast(${CRT_CONTRAST}) brightness(${CRT_BRIGHTNESS})`;
      ctx.globalCompositeOperation = CRT_COMPOSITE;
      ctx.globalAlpha = CRT_OPACITY;
      ctx.fillStyle = pat;

      // Align pattern to pixel grid (reduce shimmer)
      ctx.translate(0.5 * dpr, 0.5 * dpr);
      ctx.fillRect(-0.5 * dpr, -0.5 * dpr, w + dpr, h + dpr);

      ctx.restore();

      ctx.filter = 'none';
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }

    // ============================================================
    // Monkey neon cache
    // ============================================================
    function rebuildMonkeyCache(drawW, drawH) {
      const CACHE_SCALE = 2;
      const cw = Math.max(1, Math.round(drawW * CACHE_SCALE));
      const ch = Math.max(1, Math.round(drawH * CACHE_SCALE));

      monkeyCacheW = cw;
      monkeyCacheH = ch;

      monkeyMaskCanvas.width = cw;
      monkeyMaskCanvas.height = ch;
      monkeyLayerCanvas.width = cw;
      monkeyLayerCanvas.height = ch;

      const mctx = monkeyMaskCanvas.getContext('2d');
      mctx.setTransform(1, 0, 0, 1, 0, 0);
      mctx.clearRect(0, 0, cw, ch);
      mctx.drawImage(monkeyImg, 0, 0, cw, ch);
    }

    function ensureMonkeyCache(drawW, drawH) {
      if (!monkeyReady) return false;
      if (drawW !== monkeyCacheW || drawH !== monkeyCacheH) rebuildMonkeyCache(drawW, drawH);
      return true;
    }

    function makeTintedMonkeyLayer(colour, strokePxCss) {
      const lctx = monkeyLayerCanvas.getContext('2d');
      lctx.clearRect(0, 0, monkeyCacheW, monkeyCacheH);

      const strokePx = Math.max(0, strokePxCss * dpr);
      const half = Math.floor(strokePx / 2);

      lctx.globalCompositeOperation = 'source-over';
      for (let dx = -half; dx <= half; dx++) {
        for (let dy = -half; dy <= half; dy++) {
          lctx.drawImage(monkeyMaskCanvas, dx, dy);
        }
      }

      lctx.globalCompositeOperation = 'destination-in';
      lctx.drawImage(monkeyMaskCanvas, 0, 0);

      lctx.globalCompositeOperation = 'source-atop';
      lctx.fillStyle = colour;
      lctx.fillRect(0, 0, monkeyCacheW, monkeyCacheH);

      lctx.globalCompositeOperation = 'source-over';
    }

    function drawMonkeyNeon(x, y, tilt, drawW, drawH, extraScale = 1.0) {
      if (!ensureMonkeyCache(drawW, drawH)) return;

      const speedFactor = clamp(world.speed / world.baseSpeed, 1, 3.2);
      const tCap = clamp(world.survive / TAIL_X_CAP_S, 0, 1);

      const xNorm = clamp((speedFactor - 1) / (3.2 - 1), 0, 1) * tCap;
      const vNorm = clamp(Math.abs(tailVyFilt) / Math.max(1e-6, TAIL_VY_FOR_MAX), 0, 1);
      const ySign = (tailVyFilt >= 0) ? -1 : 1;

      const M_BLUE = 0.45;
      const M_GOLD = 0.70;
      const M_RED  = 1.00;

      const xLagBlue = -TAIL_X_MAX_CSS * xNorm * M_BLUE;
      const xLagGold = -TAIL_X_MAX_CSS * xNorm * M_GOLD;
      const xLagRed  = -TAIL_X_MAX_CSS * xNorm * M_RED;

      const yLagBlue = (TAIL_Y_MAX_CSS * vNorm * M_BLUE) * ySign;
      const yLagGold = (TAIL_Y_MAX_CSS * vNorm * M_GOLD) * ySign;
      const yLagRed  = (TAIL_Y_MAX_CSS * vNorm * M_RED ) * ySign;

      const goldOff = { x: (MONKEY_GOLD_OFF_CSS.x + xLagGold) * dpr, y: (MONKEY_GOLD_OFF_CSS.y + yLagGold) * dpr };
      const redOff  = { x: (MONKEY_RED_OFF_CSS.x  + xLagRed ) * dpr, y: (MONKEY_RED_OFF_CSS.y  + yLagRed ) * dpr };
      const blueOff = { x: (MONKEY_BLUE_OFF_CSS.x + xLagBlue) * dpr, y: (MONKEY_BLUE_OFF_CSS.y + yLagBlue) * dpr };
      const aquaOff = { x: MONKEY_AQUA_OFF_CSS.x * dpr, y: MONKEY_AQUA_OFF_CSS.y * dpr };

      const sBlue = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_BLUE;
      const sGold = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_GOLD;
      const sRed  = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_RED;

      const layers = [
        { colour: MONKEY_AQUA_COLOUR, blurCss: MONKEY_AURA_BLUR_PX, dx: aquaOff.x, dy: aquaOff.y, stroke: MONKEY_AQUA_STROKE_PX, mode: 'hard-light', scale: 1.0 },
        { colour: MONKEY_GOLD_COLOUR, blurCss: MONKEY_GLOW_BLUR_PX, dx: goldOff.x, dy: goldOff.y, stroke: MONKEY_GOLD_STROKE_PX, mode: 'normal',     scale: sGold },
        { colour: MONKEY_RED_COLOUR,  blurCss: MONKEY_GLOW_BLUR_PX, dx: redOff.x,  dy: redOff.y,  stroke: MONKEY_RED_STROKE_PX,  mode: 'normal',     scale: sRed  },
        { colour: MONKEY_BLUE_COLOUR, blurCss: MONKEY_GLOW_BLUR_PX, dx: blueOff.x, dy: blueOff.y, stroke: MONKEY_BLUE_STROKE_PX, mode: 'normal',     scale: sBlue },
        { colour: MONKEY_BASE_COLOUR, blurCss: 0,                   dx: 0,         dy: 0,          stroke: MONKEY_BASE_STROKE_PX, mode: 'normal',     scale: 1.0 },
      ];

      for (const L of layers) {
        makeTintedMonkeyLayer(L.colour, L.stroke);

        ctx.save();
        ctx.translate(x + L.dx, y + L.dy);
        ctx.rotate(tilt);

        const sLocal = (L.scale && L.scale !== 1) ? (L.scale * extraScale) : extraScale;
        if (sLocal !== 1) ctx.scale(sLocal, sLocal);

        ctx.filter = (L.blurCss > 0) ? `blur(${(L.blurCss * dpr).toFixed(4)}px)` : 'none';
        ctx.globalCompositeOperation = (L.mode === 'hard-light') ? 'hard-light' : 'source-over';

        if (L.colour === MONKEY_BASE_COLOUR) ctx.globalAlpha = MONKEY_BASE_ALPHA;
        else if (L.colour === MONKEY_AQUA_COLOUR) ctx.globalAlpha = MONKEY_AURA_ALPHA;
        else ctx.globalAlpha = MONKEY_GLOW_ALPHA;

        const passes = (L.colour === MONKEY_BASE_COLOUR) ? MONKEY_BASE_PASSES : 1;
        for (let i = 0; i < passes; i++) {
          ctx.drawImage(monkeyLayerCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
        }

        ctx.restore();
      }

      ctx.globalAlpha = 1;
      ctx.filter = 'none';
      ctx.globalCompositeOperation = 'source-over';
    }

    // ============================================================
    // Collision
    // ============================================================
    const COLL_ROT_DEG = -24;
    const COLL_ROT = (COLL_ROT_DEG * Math.PI) / 180;
    const COLL_A_FRAC = 0.40;
    const COLL_B_FRAC = 0.15;
    const COLL_CX_OFF_FRAC = 0.05;
    const COLL_CY_OFF_FRAC = 0.03;

    function ellipseRectHit(cx, cy, a, b, theta, rx, ry, rw, rh) {
      const cosT = Math.cos(-theta);
      const sinT = Math.sin(-theta);

      function toEllipseSpace(x, y) {
        const dx = x - cx;
        const dy = y - cy;
        const ex = dx * cosT - dy * sinT;
        const ey = dx * sinT + dy * cosT;
        return { x: ex, y: ey };
      }
      function insideEllipse(ex, ey) {
        const nx = ex / a;
        const ny = ey / b;
        return (nx * nx + ny * ny) <= 1;
      }

      const corners = [
        [rx, ry],
        [rx + rw, ry],
        [rx, ry + rh],
        [rx + rw, ry + rh],
      ];
      for (const [x, y] of corners) {
        const p = toEllipseSpace(x, y);
        if (insideEllipse(p.x, p.y)) return true;
      }

      const closestX = clamp(cx, rx, rx + rw);
      const closestY = clamp(cy, ry, ry + rh);
      const q = toEllipseSpace(closestX, closestY);
      if (insideEllipse(q.x, q.y)) return true;

      const samplesPerEdge = 3;
      for (let i = 1; i <= samplesPerEdge; i++) {
        const t = i / (samplesPerEdge + 1);

        let sx = rx + t * rw, sy = ry;
        let p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx + t * rw; sy = ry + rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx; sy = ry + t * rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx + rw; sy = ry + t * rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;
      }

      return false;
    }

    function cssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function drawEllipseDebug(cx, cy, a, b, theta) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(theta);

      ctx.globalAlpha = 0.18;
      ctx.fillStyle = DEBUG_COLL_COLOUR;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2 * dpr;
      ctx.strokeStyle = DEBUG_COLL_COLOUR;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(-a, 0);
      ctx.lineTo(a, 0);
      ctx.stroke();

      ctx.restore();
    }

    // ============================================================
    // Game state (physics/mechanics unchanged)
    // ============================================================
    const player = { x: 0, y: 0, vy: 0, tilt: 0 };

    const world = {
      started: false,
      over: false,
      hasStartedOnce: false,

      survive: 0,
      playT: 0,
      baseSpeed: 180,
      speed: 180,
      speedHold: 0,
      pendingPlayTRewind: 0,
      groundPad: 22,
      topPad: 22,
      distAcc: 0,
      nextSpawnDist: 760,
      obstacles: [],
      nextRestAt: REST_EVERY_S,
      restPending: false,
      resting: false,
      returning: false,
      restT: 0,
      returnT: 0,
      restScale: 1,
      restUiAlpha: 0,

      helpOpen: false
    };

    const G = 2200;
    const K_BASE = 30;
    const K_BOOST = 1.2;
    const DAMP_BASE = 22;
    const VTERM = 2400;

    const G_FALL_SCALE_MIN = 0.02;
    const G_FALL_CC_MAX = 100;

    // ============================================================
    // CC2 + pulse gating (ALWAYS 3 pulses, as requested)
    // ============================================================
    let cc2 = 0;
    function setCC2(v) { cc2 = clamp(v | 0, 0, 127); }

    const PULSE_THRESHOLD = 32;
    const PULSE_WINDOW_S = 1.6;

    let prevCC2 = 0;
    let pulseCount = 0;
    let pulseWindowT = 0;

    function resetPulses() {
      pulseCount = 0;
      pulseWindowT = 0;
      prevCC2 = cc2;
    }

    function registerPulse(dt) {
      if (!currentInput) {
        resetPulses();
        return;
      }

      const rising = (prevCC2 < PULSE_THRESHOLD) && (cc2 >= PULSE_THRESHOLD);
      prevCC2 = cc2;

      if (pulseWindowT > 0) {
        pulseWindowT = Math.max(0, pulseWindowT - dt);
        if (pulseWindowT === 0) pulseCount = 0;
      }

      if (rising) {
        if (pulseWindowT === 0) {
          pulseWindowT = PULSE_WINDOW_S;
          pulseCount = 1;
        } else {
          pulseCount += 1;
        }

        if (pulseCount >= 3) {
          pulseCount = 0;
          pulseWindowT = 0;

          if (!world.started && !world.over) startGame();
          else if (world.over) startGame();
        }
      }
    }

    // ============================================================
    // Obstacles (unchanged)
    // ============================================================
    function spawnObstacle(w, h) {
      const groundY = computeGroundY(w, h);
      const ceilingY = world.topPad;

      const gap = 150;
      const kind = (Math.random() < 0.55) ? 'pipe' : 'block';

      if (kind === 'pipe') {
        const pipeW = 56 * dpr;
        const gapCentreMin = ceilingY + 90 * dpr;
        const gapCentreMax = groundY - 90 * dpr;
        const gapCentre = clamp(
          Math.round(gapCentreMin + Math.random() * (gapCentreMax - gapCentreMin)),
          gapCentreMin, gapCentreMax
        );

        const topH = Math.max(20 * dpr, Math.round((gapCentre - (gap * dpr) / 2) - ceilingY));
        const botY = Math.round(gapCentre + (gap * dpr) / 2);
        const botH = Math.max(20 * dpr, Math.round(groundY - botY));

        world.obstacles.push({
          kind: 'pipe',
          x: w + 20 * dpr,
          w: pipeW,
          top: { y: ceilingY, w: pipeW, h: topH },
          bot: { y: botY,     w: pipeW, h: botH }
        });
      } else {
        const blockW = Math.round((46 + Math.random() * 46) * dpr);
        const blockH = Math.round((50 + Math.random() * 140) * dpr);
        world.obstacles.push({
          kind: 'block',
          x: w + 20 * dpr,
          y: groundY - blockH,
          w: blockW,
          h: blockH,
        });
      }
    }

    // ============================================================
    // On-CRT UI drawing helpers
    // ============================================================
    const UI_BOTTOM_BAND_PX = 56; // CSS px reserved for bottom controls

    // Extra horizontal inset to keep UI away from rounded corners (fraction of radius)
    const UI_CORNER_INSET_FRAC = 0.60; // try 0.50..0.80

    const ui = {
      musicRect: null,
      helpRect: null,
      backRect: null
    };

    function uiScalePx() {
      return clamp((renderCanvas.width / dpr) / 980, 0.90, 1.10);
    }

    function computeGroundY(w, h) {
      const s = uiScalePx();
      const m = Math.round(10 * s * dpr);
      const by = h - m - Math.round(26 * s * dpr);

      const groundYPhys = h - world.groundPad;
      const groundYUiCap = by - Math.round(10 * s * dpr);

      return Math.min(groundYPhys, groundYUiCap);
    }

    function roundRectPath(c, x, y, w, h, r) {
      const rr = Math.min(r, w * 0.5, h * 0.5);
      c.beginPath();
      c.moveTo(x + rr, y);
      c.arcTo(x + w, y, x + w, y + h, rr);
      c.arcTo(x + w, y + h, x, y + h, rr);
      c.arcTo(x, y + h, x, y, rr);
      c.arcTo(x, y, x + w, y, rr);
      c.closePath();
    }

    function clipSceneToScreen(w, h) {
      const r = Math.max(0, Math.round(SCREEN_CORNER_RADIUS_PX * dpr));
      if (r <= 0) return;

      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // ensure clip path is in canvas pixel space
      roundRectPath(ctx, 0, 0, w, h, r);
      ctx.clip();
    }

    function drawPillAt(x, y, w, h, fillAlpha = 0.28, borderAlpha = 0.40) {
      ctx.save();
      ctx.globalAlpha = fillAlpha;
      ctx.fillStyle = 'rgba(0,0,0,1)';
      roundRectPath(ctx, x, y, w, h, 999 * dpr);
      ctx.fill();

      ctx.globalAlpha = borderAlpha;
      ctx.strokeStyle = cssVar('--border');
      ctx.lineWidth = Math.max(1, Math.round(1 * dpr));
      ctx.stroke();
      ctx.restore();
    }

    function pillMetrics(text, fontPx, padX, padY) {
      ctx.save();
      ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
      const tw = Math.ceil(ctx.measureText(text).width);
      ctx.restore();
      const h = Math.round(fontPx + padY * 2);
      const w = tw + padX * 2;
      return { w, h };
    }

    function drawTextPill(x, y, text, opts = {}) {
      const s = uiScalePx();
      const padX = Math.round(10 * s * dpr);
      const padY = Math.round(6 * s * dpr);
      const fontPx = Math.round((12 * s) * dpr);

      const { w, h } = pillMetrics(text, fontPx, padX, padY);
      drawPillAt(x, y, w, h, opts.alpha ?? 0.28, opts.borderAlpha ?? 0.40);

      ctx.save();
      ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'left';
      ctx.globalAlpha = opts.textAlpha ?? 0.90;
      ctx.fillStyle = opts.colour ?? cssVar('--muted');
      ctx.fillText(text, x + padX, y + Math.round(h * 0.5));
      ctx.restore();

      return { x, y, w, h };
    }

    function drawCircleButton(cx, cy, r, opts = {}) {
      ctx.save();
      ctx.globalAlpha = opts.alpha ?? 0.90;
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = opts.borderAlpha ?? 0.45;
      ctx.strokeStyle = cssVar('--border');
      ctx.lineWidth = Math.max(1, Math.round(1 * dpr));
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawSpeakerIcon(cx, cy, size, on) {
      // Minimal speaker glyph (no emoji) so it remains stylistically coherent.
      const s = size;
      const x = cx - s * 0.45;
      const y = cy - s * 0.35;

      ctx.save();
      ctx.globalAlpha = on ? 0.95 : 0.65;
      ctx.strokeStyle = on ? cssVar('--text') : cssVar('--muted');
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = Math.max(1, Math.round(1.6 * dpr));
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Speaker body (filled polygon)
      ctx.beginPath();
      ctx.moveTo(x, y + s * 0.25);
      ctx.lineTo(x + s * 0.22, y + s * 0.25);
      ctx.lineTo(x + s * 0.42, y + s * 0.10);
      ctx.lineTo(x + s * 0.42, y + s * 0.60);
      ctx.lineTo(x + s * 0.22, y + s * 0.45);
      ctx.lineTo(x, y + s * 0.45);
      ctx.closePath();
      ctx.fill();

      // Waves
      if (on) {
        ctx.beginPath();
        ctx.arc(x + s * 0.48, y + s * 0.35, s * 0.18, -0.55, 0.55);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x + s * 0.48, y + s * 0.35, s * 0.30, -0.55, 0.55);
        ctx.stroke();
      } else {
        // Muted X
        ctx.beginPath();
        ctx.moveTo(x + s * 0.54, y + s * 0.18);
        ctx.lineTo(x + s * 0.80, y + s * 0.52);
        ctx.moveTo(x + s * 0.80, y + s * 0.18);
        ctx.lineTo(x + s * 0.54, y + s * 0.52);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawGradientTitle(text, x, y, fontPx) {
      const g = ctx.createLinearGradient(x - fontPx * 2.0, y, x + fontPx * 2.0, y);
      g.addColorStop(0.0, cssVar('--accentA'));
      g.addColorStop(1.0, cssVar('--accentB'));

      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `900 ${fontPx}px Orbitron, system-ui, sans-serif`;

      // subtle glow
      ctx.globalAlpha = 0.20;
      ctx.shadowColor = cssVar('--accentA');
      ctx.shadowBlur = Math.round(14 * dpr);
      ctx.fillStyle = g;
      ctx.fillText(text, x, y);

      ctx.shadowColor = cssVar('--accentB');
      ctx.shadowBlur = Math.round(18 * dpr);
      ctx.fillText(text, x, y);

      // main
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.98;
      ctx.fillStyle = g;
      ctx.fillText(text, x, y);

      ctx.restore();
    }

    function drawHelpOverlay(w, h) {
      const s = uiScalePx();

      // === Transparency controls (adjust these) ===
      const HELP_DIM_ALPHA = 0.45;   // backdrop dim (0..1). Higher = darker background.
      const HELP_BOX_ALPHA = 0.92;   // panel opacity (0..1). Higher = more opaque panel.
      // ===========================================

      // Backdrop
      ctx.save();
      ctx.globalAlpha = HELP_DIM_ALPHA;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      ctx.restore();

      // Panel box
      const boxW = Math.round(w * 0.86);
      const boxH = Math.round(h * 0.68);
      const boxX = Math.round((w - boxW) * 0.5);
      const boxY = Math.round((h - boxH) * 0.5);
      const r = Math.round(16 * s * dpr);

      ctx.save();
      ctx.globalAlpha = HELP_BOX_ALPHA;
      ctx.fillStyle = 'rgba(0,0,0,0.78)';
      roundRectPath(ctx, boxX, boxY, boxW, boxH, r);
      ctx.fill();

      ctx.globalAlpha = 0.70;
      ctx.strokeStyle = cssVar('--border');
      ctx.lineWidth = Math.max(1, Math.round(1 * dpr));
      ctx.stroke();

      // Text metrics
      const pad = Math.round(18 * s * dpr);
      const x0 = boxX + pad;
      let y0 = boxY + pad;

      const titlePx = Math.round((14 * s) * dpr);
      const bodyPx  = Math.round((12 * s) * dpr);
      const lineH   = Math.round((18 * s) * dpr);

      const colText  = cssVar('--text');
      const colMuted = cssVar('--muted');

      function drawLine(text, opts = {}) {
        ctx.save();
        ctx.globalAlpha = opts.alpha ?? 0.92;
        ctx.fillStyle = opts.colour ?? colMuted;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.font = `${opts.weight ?? 400} ${opts.sizePx ?? bodyPx}px ${opts.family ?? '"JetBrains Mono", ui-monospace, monospace'}`;
        ctx.fillText(text, x0, y0);
        ctx.restore();
        y0 += (opts.advance ?? lineH);
      }

      // Title
      drawLine('Browser & MIDI Setup', {
        colour: colText,
        alpha: 0.95,
        weight: 900,
        sizePx: titlePx,
        family: 'Orbitron, system-ui, sans-serif',
        advance: Math.round(lineH * 1.1)
      });

      drawLine('Ventra uses WebMIDI. Support depends on browser.', {
        colour: colMuted,
        alpha: 0.90,
        advance: Math.round(lineH * 1.2)
      });

      // Bullet sections (Chrome/Firefox/Safari)
      const bullet = '• ';

      // Chrome / Edge
      drawLine(`${bullet}Chrome / Edge (recommended):`, { colour: colText, alpha: 0.92, weight: 800 });
      drawLine('WebMIDI works natively. Plug in Ventra and refresh if not detected.', {
        colour: colMuted, alpha: 0.92, advance: Math.round(lineH * 1.15)
      });

      // Firefox
      drawLine(`${bullet}Firefox:`, { colour: colText, alpha: 0.92, weight: 800 });

      drawLine('1) Close Firefox. Plug in Ventra. Reopen Firefox. (Otherwise Firefox may show no MIDI ports.)', { alpha: 0.92 });
      drawLine('2) When prompted, Allow MIDI device access (and SysEx if requested).', { alpha: 0.92 });
      drawLine('3) For music: click the speaker button once (autoplay is often blocked).', { alpha: 0.92 });

      drawLine('If MIDI still does not work: open about:config → set dom.webmidi.enabled to true → refresh.', {
        alpha: 0.92, advance: Math.round(lineH * 1.25)
      });

      // Safari
      drawLine(`${bullet}Safari (macOS):`, { colour: colText, alpha: 0.92, weight: 800 });
      drawLine('Develop → Experimental Features → enable WebMIDI. Restart browser if required.', {
        colour: colMuted, alpha: 0.92, advance: Math.round(lineH * 1.25)
      });

      // Controls
      drawLine('Controls:', { colour: colText, alpha: 0.92, weight: 800, advance: Math.round(lineH * 1.05) });
      drawLine('• Breath controls height via CC2.', { alpha: 0.92 });
      drawLine('• Start / restart: three breath pulses.', { alpha: 0.92, advance: Math.round(lineH * 1.15) });

      // Close hint
      drawLine('Click anywhere to close this help.', { colour: colMuted, alpha: 0.85 });

      ctx.restore();
    }

    // ============================================================
    // UI hit rectangles (scene-space, pre-barrel) in device pixels
    // ============================================================
    function rectHit(r, x, y) {
      if (!r) return false;
      return x >= r.x && x <= (r.x + r.w) && y >= r.y && y <= (r.y + r.h);
    }

    function clientToViewPx(evt) {
      const rect = canvas.getBoundingClientRect();
      const xCss = evt.clientX - rect.left;
      const yCss = evt.clientY - rect.top;
      return { x: xCss * dpr, y: yCss * dpr };
    }

    canvas.addEventListener('click', async (e) => {
      // Ensure AudioContext is resumed on a user gesture.
      try { await ensureAudioFX(); } catch {}

      const { w, h } = resizeCanvasToDisplaySize();
      const v = clientToViewPx(e);
      const sxy = viewToScene(v.x, v.y, w, h);

      // Help open: click anywhere closes
      if (world.helpOpen) {
        world.helpOpen = false;
        return;
      }

      if (rectHit(ui.musicRect, sxy.x, sxy.y)) {
        setAudio(!audioOn);
        // If we turned ON, try to start immediately (interaction occurred)
        if (audioOn && world.started) await startMusicIfArmed();
        return;
      }

      if (rectHit(ui.helpRect, sxy.x, sxy.y)) {
        world.helpOpen = true;
        return;
      }

      if (rectHit(ui.backRect, sxy.x, sxy.y)) {
        window.location.href = './index.html';
        return;
      }
    });

    // ============================================================
    // Game lifecycle
    // ============================================================
    function resetGame() {
      const { w, h } = resizeCanvasToDisplaySize();

      world.started = false;
      world.over = false;

      world.survive = 0;
      world.playT = 0;
      world.speed = world.baseSpeed;

      world.distAcc = 0;
      world.obstacles = [];
      world.nextSpawnDist = 620;

      world.nextRestAt = REST_EVERY_S;
      world.restPending = false;
      world.resting = false;
      world.returning = false;
      world.restT = 0;
      world.returnT = 0;
      world.restScale = 1;
      world.restUiAlpha = 0;

      // Start screen: monkey waits centred.
      player.x = Math.round(w * 0.50);
      player.y = Math.round(h * 0.54);
      player.vy = 0;
      player.tilt = 0;

      tailVyFilt = 0;
      resetPulses();
    }

    function startGame() {
      if (!currentInput) return;

      if (world.over) resetGame();

      world.started = true;
      world.over = false;
      world.hasStartedOnce = true;

      const { w, h } = resizeCanvasToDisplaySize();
      player.x = Math.round(w * 0.22);
      player.y = Math.round(h * 0.50);
      player.vy = 0;
      player.tilt = 0;
      tailVyFilt = 0;

      resetPulses();
      startMusicIfArmed();
    }

    function gameOver() {
      world.over = true;
      world.started = false;

      resetPulses();
      stopMusic();

      world.restPending = false;
      world.resting = false;
      world.returning = false;
      world.restT = 0;
      world.returnT = 0;
      world.restScale = 1;
      world.restUiAlpha = 0;

      const { w, h } = resizeCanvasToDisplaySize();
      player.x = Math.round(w * 0.50);
      player.y = Math.round(h * 0.54);
      player.vy = 0;
      player.tilt = 0;
      tailVyFilt = 0;
    }

    // ============================================================
    // Drawing
    // ============================================================
    const GLASS_STRENGTH = 0.2;   // 0..2 (visual)
    const GLASS_VIGNETTE = 0.9;   // 0..1
    const GLASS_HIGHLIGHT = 2;  // 0..1

    function drawGlassShading(w, h) {
      if (GLASS_STRENGTH <= 0) return;

      ctx.save();

      // Highlight (soft-light style approximation using screen/overlay-ish)
      ctx.globalAlpha = 0.18 * GLASS_STRENGTH * GLASS_HIGHLIGHT;
      ctx.globalCompositeOperation = 'screen';
      let g = ctx.createRadialGradient(w * 0.50, h * 0.10, 0, w * 0.50, h * 0.10, Math.max(w, h) * 0.9);
      g.addColorStop(0.00, 'rgba(255,255,255,0.55)');
      g.addColorStop(0.35, 'rgba(255,255,255,0.12)');
      g.addColorStop(0.60, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      // Vignette (edge darkening)
      ctx.globalAlpha = 0.55 * GLASS_STRENGTH * GLASS_VIGNETTE;
      ctx.globalCompositeOperation = 'multiply';
      g = ctx.createRadialGradient(w * 0.50, h * 0.55, Math.min(w, h) * 0.35, w * 0.50, h * 0.55, Math.max(w, h) * 0.75);
      g.addColorStop(0.00, 'rgba(0,0,0,0.00)');
      g.addColorStop(1.00, 'rgba(0,0,0,0.85)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      ctx.restore();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
    }

    function drawScene(w, h) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, w, h);

      // Apply screen rounding in SCENE space (pre-barrel)
      clipSceneToScreen(w, h);

      const border = cssVar('--border');
      const accentA = cssVar('--accentA');
      const accentB = cssVar('--accentB');
      const text = cssVar('--text');
      const muted = cssVar('--muted');

      // Background remains black; add subtle vignette
      ctx.save();
      const v = ctx.createRadialGradient(w * 0.5, h * 0.5, Math.min(w, h) * 0.10, w * 0.5, h * 0.5, Math.min(w, h) * 0.80);
      v.addColorStop(0.0, 'rgba(0,0,0,0.00)');
      v.addColorStop(1.0, 'rgba(0,0,0,0.55)');
      ctx.fillStyle = v;
      ctx.fillRect(0, 0, w, h);
      ctx.restore();

      // Bottom UI placement (used to avoid the ground line cutting through buttons)
      const s = uiScalePx();
      const m = Math.round(10 * s * dpr);
      const by = h - m - Math.round(26 * s * dpr);

      // Horizontal-only safe margin (vertical stays exactly as before)
      const insetX = Math.round(SCREEN_CORNER_RADIUS_PX * UI_CORNER_INSET_FRAC * dpr);
      const mX = m + insetX;

      // Physics ground (unchanged)
      const groundYPhys = h - world.groundPad;

      // Visual ground line: keep it ABOVE the bottom controls
      const groundYDraw = computeGroundY(w, h);

      // Draw ground line
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = border;
      ctx.lineWidth = 2 * dpr;
      ctx.beginPath();
      ctx.moveTo(0, groundYDraw + 1);
      ctx.lineTo(w, groundYDraw + 1);
      ctx.stroke();
      ctx.restore();

      // Obstacles
      for (const ob of world.obstacles) {
        if (ob.kind === 'pipe') {
          ctx.fillStyle = accentA;
          ctx.fillRect(ob.x, ob.top.y, ob.top.w, ob.top.h);
          ctx.fillStyle = accentB;
          ctx.fillRect(ob.x, ob.bot.y, ob.bot.w, ob.bot.h);

          ctx.strokeStyle = border;
          ctx.lineWidth = 1 * dpr;
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.top.y + 0.5 * dpr, ob.top.w - 1 * dpr, ob.top.h - 1 * dpr);
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.bot.y + 0.5 * dpr, ob.bot.w - 1 * dpr, ob.bot.h - 1 * dpr);
        } else {
          ctx.fillStyle = accentA;
          ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
          ctx.strokeStyle = border;
          ctx.lineWidth = 1 * dpr;
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.y + 0.5 * dpr, ob.w - 1 * dpr, ob.h - 1 * dpr);
        }
      }

      // Player
      const drawW = MONKEY_DRAW_W * dpr;
      const drawH = MONKEY_DRAW_H * dpr;

      if (monkeyReady) {
        const sLocal = (world.resting || world.returning) ? world.restScale : 1;
        drawMonkeyNeon(player.x, player.y, player.tilt, drawW, drawH, sLocal);
      } else {
        ctx.save();
        ctx.fillStyle = text;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 14 * dpr, 0, Math.PI * 2);
        ctx.fill();

        const pct = cc2 / 127;
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = (pct > 0.01) ? cssVar('--warn') : muted;
        ctx.beginPath();
        ctx.arc(player.x, player.y, Math.max(3 * dpr, Math.round(14 * dpr * (0.25 + 0.35 * pct))), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // =========================
      // On-CRT UI (NO duplication)
      // =========================
      const topY = m;

      const ventraText = (!('requestMIDIAccess' in navigator))
        ? 'Ventra not supported in this browser'
        : (currentInput ? 'Ventra connected' : 'Ventra not connected — plug in and refresh');

      const left = drawTextPill(mX, topY, ventraText, { colour: currentInput ? cssVar('--text') : cssVar('--muted'), alpha: 0.28 });

      const ccText = `CC2: ${String(cc2).padStart(3, '0')}`;
      // measure-first for right aligned (no redraw)
      {
        const s2 = uiScalePx();
        const padX = Math.round(10 * s2 * dpr);
        const padY = Math.round(6 * s2 * dpr);
        const fontPx = Math.round((12 * s2) * dpr);
        const { w: pillW, h: pillH } = pillMetrics(ccText, fontPx, padX, padY);
        const x = w - mX - pillW;
        drawPillAt(x, topY, pillW, pillH, 0.28, 0.40);

        ctx.save();
        ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'left';
        ctx.globalAlpha = 0.90;
        ctx.fillStyle = cssVar('--muted');
        ctx.fillText(ccText, x + padX, topY + Math.round(pillH * 0.5));
        ctx.restore();
      }

      // HUD (time/speed) on the right during play
      if (world.started && !world.over) {
        const t1 = `Time: ${world.survive.toFixed(1)} s`;
        const t2 = `Speed: ${world.speed.toFixed(0)}`;
        const hudY = topY + Math.round(32 * s * dpr);

        // time
        {
          const s2 = uiScalePx();
          const padX = Math.round(10 * s2 * dpr);
          const padY = Math.round(6 * s2 * dpr);
          const fontPx = Math.round((12 * s2) * dpr);
          const { w: pillW, h: pillH } = pillMetrics(t1, fontPx, padX, padY);
          const x = w - mX - pillW;
          drawPillAt(x, hudY, pillW, pillH, 0.22, 0.30);
          ctx.save();
          ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'left';
          ctx.globalAlpha = 0.80;
          ctx.fillStyle = cssVar('--muted');
          ctx.fillText(t1, x + padX, hudY + Math.round(pillH * 0.5));
          ctx.restore();
        }

        // speed
        {
          const s2 = uiScalePx();
          const padX = Math.round(10 * s2 * dpr);
          const padY = Math.round(6 * s2 * dpr);
          const fontPx = Math.round((12 * s2) * dpr);
          const { w: pillW, h: pillH } = pillMetrics(t2, fontPx, padX, padY);
          const y = hudY + Math.round(28 * s * dpr);
          const x = w - mX - pillW;
          drawPillAt(x, y, pillW, pillH, 0.22, 0.30);
          ctx.save();
          ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'left';
          ctx.globalAlpha = 0.80;
          ctx.fillStyle = cssVar('--muted');
          ctx.fillText(t2, x + padX, y + Math.round(pillH * 0.5));
          ctx.restore();
        }
      }

      // Bottom controls: Back pill + Help circle + Speaker circle
      // Back pill
      const back = drawTextPill(mX, by, 'Back', { colour: cssVar('--muted'), alpha: 0.28 });
      ui.backRect = back;

      // Help circle (right)
      const rBtn = Math.round(13 * s * dpr);
      const helpCx = w - mX - rBtn;
      const helpCy = by + rBtn;
      drawCircleButton(helpCx, helpCy, rBtn, { alpha: 0.90, borderAlpha: 0.45 });
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = cssVar('--text');
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `900 ${Math.round(14 * s * dpr)}px Orbitron, system-ui, sans-serif`;
      ctx.fillText('?', helpCx, helpCy + Math.round(0.5 * dpr));
      ctx.restore();
      ui.helpRect = { x: helpCx - rBtn, y: helpCy - rBtn, w: rBtn * 2, h: rBtn * 2 };

      // Speaker circle (left of help)
      const spCx = helpCx - Math.round((2 * rBtn + 10 * s * dpr));
      const spCy = helpCy;
      drawCircleButton(spCx, spCy, rBtn, { alpha: 0.90, borderAlpha: 0.45 });
      drawSpeakerIcon(spCx, spCy, Math.round(18 * s * dpr), audioOn);
      ui.musicRect = { x: spCx - rBtn, y: spCy - rBtn, w: rBtn * 2, h: rBtn * 2 };

      // Start screen title + instruction
      if (!world.started && !world.over) {
        const bigPx = Math.round((40 * s) * dpr);
        const smallPx = Math.round((16 * s) * dpr);

        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `900 ${smallPx}px Orbitron, system-ui, sans-serif`;
        ctx.globalAlpha = 0.70;
        ctx.fillStyle = muted;
        ctx.fillText('VENTRA', Math.round(w * 0.5), Math.round(h * 0.205));
        ctx.restore();

        drawGradientTitle('EXHALE//ASCEND', Math.round(w * 0.5), Math.round(h * 0.26), bigPx);

        const msg = currentInput
          ? 'Start with three breath pulses'
          : 'Plug in Ventra, refresh, then start';

        const prog = currentInput
          ? `Pulses: ${String(pulseCount).padStart(1, '0')} / 3`
          : 'Waiting for MIDI device…';

        ctx.save();
        const tPx = Math.round((12 * s) * dpr);
        ctx.font = `${tPx}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.fillStyle = muted;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.92;
        ctx.fillText(msg, Math.round(w * 0.5), Math.round(h * 0.34));
        ctx.globalAlpha = 0.75;
        ctx.fillText(prog, Math.round(w * 0.5), Math.round(h * 0.38));
        ctx.restore();
      }

      // Game-over overlay
      if (world.over) {
        const s2 = uiScalePx();
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        ctx.font = `900 ${Math.round(26 * s2 * dpr)}px Orbitron, system-ui, sans-serif`;
        ctx.fillStyle = text;
        ctx.globalAlpha = 0.92;
        ctx.fillText('GAME OVER', Math.round(w * 0.5), Math.round(h * 0.26));

        ctx.font = `${Math.round(12 * s2 * dpr)}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.fillStyle = muted;
        ctx.globalAlpha = 0.88;
        ctx.fillText(`Survived: ${world.survive.toFixed(1)} s`, Math.round(w * 0.5), Math.round(h * 0.34));
        ctx.fillText('Restart with three breath pulses', Math.round(w * 0.5), Math.round(h * 0.38));
        ctx.restore();
      }

      // Breath phase overlay (unchanged)
      if (world.started && (world.resting || world.returning)) {
        const aUi = clamp(world.restUiAlpha, 0, 1);
        if (aUi > 0) {
          ctx.save();
          ctx.globalAlpha = REST_DIM_ALPHA * aUi;
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, w, h);
          ctx.restore();

          const dur = restDurationS();
          const u = clamp(world.restT / Math.max(1e-6, dur), 0, 1);
          const stepU = 1 / REST_COUNT;
          const idx = clamp(Math.floor(u / stepU), 0, REST_COUNT - 1);
          const countVal = Math.max(1, REST_COUNT - idx);

          ctx.save();
          ctx.globalAlpha = 0.92 * aUi;
          ctx.fillStyle = text;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          ctx.font = `${Math.round(18 * dpr)}px Orbitron, system-ui, sans-serif`;
          ctx.fillText('Breathe', Math.round(w * 0.5), Math.round(h * 0.42));

          ctx.font = `${Math.round(30 * dpr)}px Orbitron, system-ui, sans-serif`;
          ctx.fillText(String(countVal), Math.round(w * 0.5), Math.round(h * 0.50));

          ctx.font = `${Math.round(12 * dpr)}px "JetBrains Mono", ui-monospace, monospace`;
          ctx.globalAlpha = 0.78 * aUi;
          ctx.fillText('Control paused', Math.round(w * 0.5), Math.round(h * 0.58));
          ctx.restore();
        }
      }

      if (world.started && world.restPending && !world.resting && !world.returning) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = text;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.font = `${Math.round(11 * dpr)}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.fillText('Clearing…', Math.round(w - mX), Math.round(h - 44 * dpr));
        ctx.restore();
      }

      if (world.helpOpen) drawHelpOverlay(w, h);

      // Glass shading (curved-glass highlight + vignette), then CRT pattern
      drawGlassShading(w, h);

      // CRT overlay MUST be drawn over everything (title, UI, game)
      drawCrtOverlayIntoScene(w, h);

      // Film grain sits on top of the entire image
      drawFilmGrain(w, h, nowS);

      if (SHOW_COLLISION_DEBUG) {
        const a = Math.max(8 * dpr, (drawW * COLL_A_FRAC));
        const b = Math.max(6 * dpr, (drawH * COLL_B_FRAC));
        const theta = COLL_ROT + (COLL_FOLLOWS_SPRITE_TILT ? player.tilt : 0);

        const cx = player.x + (drawW * COLL_CX_OFF_FRAC);
        const cy = player.y + (drawH * COLL_CY_OFF_FRAC);

        drawEllipseDebug(cx, cy, a, b, theta);
      }

      // If we clipped, we must restore once at the end
      if (SCREEN_CORNER_RADIUS_PX > 0) ctx.restore();
    }

    // ============================================================
    // Main loop (physics/mechanics unchanged)
    // ============================================================
    let lastTs = 0;

    function step(ts) {
      const { w, h } = resizeCanvasToDisplaySize();

      nowS = ts * 0.001;

      const dt = Math.min(0.033, Math.max(0.001, (ts - (lastTs || ts)) / 1000));
      lastTs = ts;

      // If Ventra disappears mid-run: stop play and return to start screen.
      if (!currentInput) {
        setCC2(0);
        if (world.started) {
          world.started = false;
          world.over = false;
          stopMusic();
          resetPulses();
          tailVyFilt = 0;

          world.restPending = false;
          world.resting = false;
          world.returning = false;
          world.restT = 0;
          world.returnT = 0;
          world.restScale = 1;
          world.restUiAlpha = 0;

          player.x = Math.round(w * 0.50);
          player.y = Math.round(h * 0.54);
          player.vy = 0;
          player.tilt = 0;
        }
      }

      registerPulse(dt);

      const groundY = computeGroundY(w, h);
      const ceilingY = world.topPad;

      if (world.started && !world.over) {
        const inBreak = (world.resting || world.returning);

        world.survive += dt;
        if (!inBreak) world.playT += dt;

        const targetSpeed = world.baseSpeed + SPEED_RAMP_PER_S * world.playT;

        if (FREEZE_SPEED_DURING_REST && inBreak) {
          // Hold speed constant through the pause so it cannot “catch up” while resting.
          world.speed = world.speedHold || world.speed;
        } else {
          world.speed = expApproach(world.speed, targetSpeed, dt, SPEED_TAU_S);
        }

        if (!world.restPending && !inBreak && world.playT >= world.nextRestAt) {
          world.restPending = true;
        }

        const scrollVx = world.speed * dpr;
        for (const ob of world.obstacles) {
          ob.x -= scrollVx * dt;
        }

        while (world.obstacles.length && (world.obstacles[0].x + (world.obstacles[0].w || world.obstacles[0].top.w)) < -40 * dpr) {
          world.obstacles.shift();
        }

        if (world.restPending && !inBreak && world.obstacles.length === 0) {
          world.restPending = false;
          world.resting = true;
          world.returning = false;
          world.restT = 0;
          world.returnT = 0;
          world.restScale = REST_FLYIN_SCALE_FROM;
          world.restUiAlpha = 1;
          world.distAcc = 0;
          player.vy = 0;
          player.tilt = 0;
          tailVyFilt = 0;
          world.speedHold = world.speed;
          world.pendingPlayTRewind = POST_REST_PLAYT_REWIND_S;
        }

        if (world.resting) {
          world.restT += dt;

          const dur = restDurationS();
          const u = clamp(world.restT / Math.max(1e-6, dur), 0, 1);

          const centreX = Math.round(w * REST_CENTRE_X_FRAC);
          const centreY = Math.round(h * REST_CENTRE_Y_FRAC);

          player.x = expApproach(player.x, centreX, dt, REST_MOVE_TAU_S);
          player.y = expApproach(player.y, centreY, dt, REST_MOVE_TAU_S);

          player.vy = 0;
          player.tilt = 0;

          const flyU = clamp(u / Math.max(1e-6, REST_FLYIN_FRACTION), 0, 1);
          const baseScale = REST_FLYIN_SCALE_FROM + (REST_BASE_SCALE - REST_FLYIN_SCALE_FROM) * flyU;

          const phase = u * REST_PULSES * Math.PI * 2;
          const pulse01 = 0.5 - 0.5 * Math.cos(phase);
          world.restScale = baseScale * (1 + REST_PULSE_SCALE * pulse01);

          tailVyFilt = expApproach(tailVyFilt, 0, dt, 0.06);

          if (world.restT >= dur) {
            world.restT = dur;
            world.resting = false;
            world.returning = true;
            world.returnT = 0;
            world.restUiAlpha = 1;

            player.vy = 0;
            player.tilt = 0;
            tailVyFilt = 0;

            world.nextRestAt += REST_EVERY_S;
          }
        }

        if (world.returning) {
          world.returnT += dt;

          const dur = restDurationS();
          const returnS = Math.max(0.05, dur * REST_RETURN_FRACTION);

          const laneX = Math.round(w * 0.22);
          const centreY = Math.round(h * REST_CENTRE_Y_FRAC);

          world.restUiAlpha = clamp(1 - (world.returnT / Math.max(1e-6, REST_UI_FADE_S)), 0, 1);

          player.x = expApproach(player.x, laneX, dt, REST_RETURN_TAU_S);
          player.y = expApproach(player.y, centreY, dt, REST_RETURN_TAU_S);

          world.restScale = expApproach(world.restScale, 1, dt, REST_RETURN_TAU_S);

          player.vy = 0;
          player.tilt = 0;
          tailVyFilt = expApproach(tailVyFilt, 0, dt, 0.06);

          if (world.returnT >= returnS) {
            world.returning = false;
            world.returnT = 0;
            world.restUiAlpha = 0;
            world.restScale = 1;

            player.x = laneX;
            player.vy = 0;
            player.tilt = 0;
            tailVyFilt = 0;

            // Slightly reduce the ramp after a pause (optional difficulty smoothing).
            if (world.pendingPlayTRewind > 0) {
              world.playT = Math.max(0, world.playT - world.pendingPlayTRewind);
              world.pendingPlayTRewind = 0;

              // Ensure speed is not above the newly lowered target.
              const newTarget = world.baseSpeed + SPEED_RAMP_PER_S * world.playT;
              world.speed = Math.min(world.speed, newTarget);
            }
            world.distAcc = 0;
          }
        }

        if (!world.resting && !world.returning) {
          const pct = cc2 / 127;
          const maxLift = (groundY - 14 * dpr) - (ceilingY + 14 * dpr);
          const targetY = (groundY - 14 * dpr) - (pct * maxLift);

          const speedFactor = clamp(world.speed / world.baseSpeed, 1, 3.2);
          const K = K_BASE * (1 + K_BOOST * (speedFactor - 1));
          const DAMP = DAMP_BASE * (0.95 + 0.25 * (speedFactor - 1));

          const speedFade = clamp((speedFactor - 1) / (3.2 - 1), 0, 1);
          const ccFade = clamp(cc2 / G_FALL_CC_MAX, 0, 1);
          const fallScale = (G_FALL_SCALE_MIN + (1 - G_FALL_SCALE_MIN) * ccFade);
          const gEff = G * (fallScale + (1 - fallScale) * speedFade);

          let ay = (K * (targetY - player.y)) - (DAMP * player.vy) + gEff;

          player.vy += ay * dt;
          player.vy = clamp(player.vy, -VTERM * dpr, VTERM * dpr);
          player.y += player.vy * dt;

          {
            const alpha = 1 - Math.exp(-dt / Math.max(1e-6, TAIL_VY_TAU_S));
            tailVyFilt = tailVyFilt + alpha * (player.vy - tailVyFilt);
          }

          player.tilt = clamp(-player.vy / (900 * dpr), -0.20, 0.20);

          const floorY = groundY - 14 * dpr;
          if (player.y > floorY) { player.y = floorY; if (player.vy > 0) player.vy = 0; }
          const ceilY = ceilingY + 14 * dpr;
          if (player.y < ceilY) { player.y = ceilY; if (player.vy < 0) player.vy = 0; }

          const t = world.playT;
          const startMean = 760 * dpr;
          const endMean = 560 * dpr;
          const ease = clamp(t / 18, 0, 1);
          const mean = startMean + (endMean - startMean) * ease;
          const jitter = 0.18;

          world.distAcc += (world.speed * dpr) * dt;

          if (!world.restPending) {
            if (world.distAcc >= world.nextSpawnDist) {
              world.distAcc = 0;
              spawnObstacle(w, h);
              const r = (Math.random() * 2 - 1) * jitter;
              world.nextSpawnDist = Math.max(420 * dpr, mean * (1 + r));
            }
          } else {
            world.distAcc = Math.min(world.distAcc, world.nextSpawnDist - 0.001);
          }

          const drawW = MONKEY_DRAW_W * dpr;
          const drawH = MONKEY_DRAW_H * dpr;
          const a = Math.max(8 * dpr, (drawW * COLL_A_FRAC));
          const b = Math.max(6 * dpr, (drawH * COLL_B_FRAC));
          const collTheta = COLL_ROT + (COLL_FOLLOWS_SPRITE_TILT ? player.tilt : 0);

          const cx = player.x + (drawW * COLL_CX_OFF_FRAC);
          const cy = player.y + (drawH * COLL_CY_OFF_FRAC);

          for (const ob of world.obstacles) {
            if (ob.kind === 'pipe') {
              if (
                ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.top.y, ob.top.w, ob.top.h) ||
                ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.bot.y, ob.bot.w, ob.bot.h)
              ) { gameOver(); break; }
            } else {
              if (ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.y, ob.w, ob.h)) {
                gameOver(); break;
              }
            }
          }
        }
      } else {
        player.tilt = 0;
        tailVyFilt *= 0.90;
        world.restScale = 1;
        world.restUiAlpha = 0;

        if (!world.over) {
          const cx = Math.round(w * 0.50);
          const cy = Math.round(h * 0.54);
          player.x = expApproach(player.x, cx, dt, 0.12);
          player.y = expApproach(player.y, cy, dt, 0.12);
        }
      }

      drawScene(w, h);
      presentWithBarrel(w, h);

      requestAnimationFrame(step);
    }

    function onMIDIMessage(e) {
      const data = e.data;
      if (!data || data.length < 3) return;

      const status = data[0];
      const type = status & 0xF0;

      const targetStatus = 0xB0 | ((targetChannel1Based - 1) & 0x0F);
      if (type === 0xB0 && status === targetStatus && data[1] === targetCC) {
        setCC2(data[2]);
      }
    }

    // ============================================================
    // Boot
    // ============================================================
    resetGame();
    setCC2(0);
    requestAnimationFrame(step);
  </script>
</body>
</html>