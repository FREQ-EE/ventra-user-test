<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ventra · EXHALE//ASCEND</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;800;900&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root { color-scheme: dark; }

    :root{
      --bg:#000000;
      --text:#EDF4FA;
      --muted:#9AA4B2;
      --accentA:#8B5CF6;
      --accentB:#EC4899;
      --warn:#FFB86B;
      --danger:#FF6B6B;
      --border:#262C3C;
    }

    html, body { height: 100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      line-height:1.35;
      display:grid;
      place-items:center;
      overflow:hidden;
    }

    /* Single visible element: the canvas area. Outside stays pure black. */
    .gameShell{
      position:relative;
      width:min(96vw, 980px);
      aspect-ratio: 4 / 3;
      max-height: 92vh;
      background:#000;
    }

    canvas{
      display:block;
      width:100%;
      height:100%;
      background:#000;
      cursor:default;
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
    }
  </style>
</head>

<body>
  <div class="gameShell" id="gameShell" aria-label="Ventra game">
    <canvas id="game"></canvas>
  </div>

  <audio id="bgm" loop preload="auto">
    <source src="./music.ogg" type="audio/ogg">
    <source src="./music.mp3" type="audio/mpeg">
  </audio>

  <script>
    'use strict';

    function clamp(n, lo, hi) { return Math.min(hi, Math.max(lo, n)); }

    function expApproach(current, target, dt, tau) {
      const a = 1 - Math.exp(-dt / Math.max(1e-6, tau));
      return current + (target - current) * a;
    }

    const SHOW_COLLISION_DEBUG = false;
    const COLL_FOLLOWS_SPRITE_TILT = true;
    const DEBUG_COLL_COLOUR = '#00FFFF';

    // ============================================================
    // Barrel distortion (lens bulge)
    // ============================================================
    const BARREL_ENABLED = true;
    const BARREL_K = 0.075;
    const BARREL_SLICES = 128;

    // Approx inverse mapping for click hit-testing (good enough for UI).
    function viewToScene(xv, yv, w, h) {
      if (!BARREL_ENABLED || BARREL_K <= 0) return { x: xv, y: yv };

      const K = BARREL_K;
      const cx = w * 0.5;
      const cy = h * 0.5;

      // Invert second pass (x scaled by invS(y))
      const yNorm = (yv - cy) / Math.max(1e-6, cy);
      const Sy = 1 + K * (yNorm * yNorm);
      const xs = cx + (xv - cx) * Sy;

      // Invert first pass (y scaled by invS(x))
      const xNorm = (xs - cx) / Math.max(1e-6, cx);
      const Sx = 1 + K * (xNorm * xNorm);
      const ys = cy + (yv - cy) * Sx;

      return { x: xs, y: ys };
    }

    // ============================================================
    // CRT (rendered into the off-screen scene, so it gets barrel distortion)
    // ============================================================
    const CRT_OPACITY = 0.30;
    const CRT_REPEATS_X = 98;
    const CRT_BRICK_OFFSET_FRAC = 1/2;

    const CRT_COMPOSITE = 'soft-light';   // browser-dependent support
    const CRT_CONTRAST = 0.8;
    const CRT_BRIGHTNESS = 0.40;

    const crtImg = new Image();
    let crtImgReady = false;
    crtImg.onload = () => { crtImgReady = true; };
    crtImg.onerror = (e) => { console.warn('Failed to load overlay-pattern.png', e); };
    crtImg.src = './overlay-pattern.png';

    let crtPattern = null;
    let crtPatternTilePx = 0;
    let crtPatternShiftPx = -1;

    // ============================================================
    // Assets
    // ============================================================
    const monkeyImg = new Image();
    let monkeyReady = false;
    monkeyImg.onload = () => { monkeyReady = true; };
    monkeyImg.onerror = (e) => { console.warn('Failed to load monkey.svg', e); };
    monkeyImg.src = './monkey.svg';

    const MONKEY_DRAW_W = 150;
    const MONKEY_DRAW_H = 150;

    const MONKEY_BASE_STROKE_PX = 2;
    const MONKEY_GOLD_STROKE_PX = 4;
    const MONKEY_RED_STROKE_PX  = 4;
    const MONKEY_BLUE_STROKE_PX = 6;
    const MONKEY_AQUA_STROKE_PX = 6;

    const MONKEY_BASE_COLOUR = '#FFFFFF';
    const MONKEY_GOLD_COLOUR = '#FFCC33';
    const MONKEY_RED_COLOUR  = '#CC0033';
    const MONKEY_BLUE_COLOUR = '#00A3FF';
    const MONKEY_AQUA_COLOUR = '#00FFFF';

    const MONKEY_BASE_ALPHA = 0.66;
    const MONKEY_GLOW_ALPHA = 1;
    const MONKEY_AURA_ALPHA = 1;
    const MONKEY_BASE_PASSES = 3;

    const MONKEY_GLOW_BLUR_PX = 0.66;
    const MONKEY_AURA_BLUR_PX = 2;

    const MONKEY_GOLD_OFF_CSS = { x: -0,  y: 4 };
    const MONKEY_RED_OFF_CSS  = { x: -4,  y: 0 };
    const MONKEY_BLUE_OFF_CSS = { x: 4,   y: 0 };
    const MONKEY_AQUA_OFF_CSS = { x: 0,   y: 0 };

    const TAIL_X_CAP_S = 60;
    const TAIL_X_MAX_CSS = 18;
    const TAIL_Y_MAX_CSS = 20;
    const TAIL_VY_FOR_MAX = 1200;
    const TAIL_VY_TAU_S = 0.10;
    const TAIL_SCALE_MAX = 0.08;

    let tailVyFilt = 0;

    const monkeyMaskCanvas  = document.createElement('canvas');
    const monkeyLayerCanvas = document.createElement('canvas');
    let monkeyCacheW = 0;
    let monkeyCacheH = 0;

    // ============================================================
    // Rest / pause settings (unchanged)
    // ============================================================
    const REST_EVERY_S = 25;
    const REST_COUNT = 3;
    const REST_COUNT_STEP_S = 1.75;
    const REST_PULSES = 3;

    const REST_FLYIN_SCALE_FROM = 1.00;
    const REST_BASE_SCALE = 1.50;
    const REST_PULSE_SCALE = 0.10;

    const REST_DIM_ALPHA = 0.18;
    const REST_MOVE_TAU_S = 0.22;
    const REST_RETURN_TAU_S = 0.18;

    const REST_CENTRE_X_FRAC = 0.50;
    const REST_CENTRE_Y_FRAC = 0.50;

    const REST_FLYIN_FRACTION = 0.55;
    const REST_RETURN_FRACTION = 0.25;
    const REST_UI_FADE_S = 0.25;

    function restDurationS() {
      return Math.max(0.2, REST_COUNT * REST_COUNT_STEP_S);
    }

    const SPEED_RAMP_PER_S = 16;
    const SPEED_TAU_S = 0.60;

    // ============================================================
    // MIDI
    // ============================================================
    const targetChannel1Based = 1;
    const targetCC = 2;

    let midiAccess = null;
    let currentInput = null;

    function detachCurrentInput() {
      if (currentInput) currentInput.onmidimessage = null;
      currentInput = null;
    }

    function isVentraPort(p) {
      const name = (p && p.name ? String(p.name) : '').toLowerCase();
      const manu = (p && p.manufacturer ? String(p.manufacturer) : '').toLowerCase();
      return name.includes('ventra') || manu.includes('ventra');
    }

    function findVentraInput() {
      if (!midiAccess) return null;
      const inputs = Array.from(midiAccess.inputs.values());
      return inputs.find(isVentraPort) || null;
    }

    function attachVentraIfPresent() {
      detachCurrentInput();
      const input = findVentraInput();
      if (!input) return false;
      currentInput = input;
      currentInput.onmidimessage = onMIDIMessage;
      return true;
    }

    async function initMIDI() {
      if (!('requestMIDIAccess' in navigator)) return;
      try {
        midiAccess = await navigator.requestMIDIAccess({ sysex: false });
        attachVentraIfPresent();
        midiAccess.onstatechange = () => attachVentraIfPresent();
      } catch (err) {
        console.error(err);
      }
    }

    initMIDI();

    // ============================================================
    // Audio (same behaviour as before: stored pref; autoplay may block until interaction)
    // ============================================================
    const bgm = document.getElementById('bgm');
    const AUDIO_KEY = 'ventra_game_music';
    let audioOn = true;

    function loadAudioPref() {
      const saved = localStorage.getItem(AUDIO_KEY);
      audioOn = (saved === null) ? true : (saved === '1');
      if (saved === null) localStorage.setItem(AUDIO_KEY, '1');
    }
    loadAudioPref();

    function musicIsArmed() { return audioOn; }

    async function startMusicIfArmed() {
      if (!bgm) return;
      if (!musicIsArmed()) return;
      try { await bgm.play(); }
      catch (e) { /* autoplay blocks are expected */ }
    }

    function stopMusic() {
      if (!bgm) return;
      bgm.pause();
      bgm.currentTime = 0;
    }

    function setAudio(on) {
      audioOn = !!on;
      localStorage.setItem(AUDIO_KEY, audioOn ? '1' : '0');
      if (!audioOn) stopMusic();
      else if (world && world.started) startMusicIfArmed();
    }

    // ============================================================
    // Canvas setup
    // ============================================================
    const canvas = document.getElementById('game');
    const viewCtx = canvas.getContext('2d', { alpha: false });

    const renderCanvas = document.createElement('canvas');
    const ctx = renderCanvas.getContext('2d');

    const distortCanvas = document.createElement('canvas');
    const dctx = distortCanvas.getContext('2d');

    let dpr = 1;

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      const w = Math.max(320, Math.round(rect.width * dpr));
      const h = Math.max(240, Math.round(rect.height * dpr));

      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      if (renderCanvas.width !== w || renderCanvas.height !== h) {
        renderCanvas.width = w;
        renderCanvas.height = h;
      }
      if (distortCanvas.width !== w || distortCanvas.height !== h) {
        distortCanvas.width = w;
        distortCanvas.height = h;
      }

      return { w, h };
    }

    // ============================================================
    // Barrel presentation (unchanged)
    // ============================================================
    function presentWithBarrel(w, h) {
      if (!BARREL_ENABLED || BARREL_K <= 0) {
        viewCtx.setTransform(1, 0, 0, 1, 0, 0);
        viewCtx.clearRect(0, 0, w, h);
        viewCtx.drawImage(renderCanvas, 0, 0);
        return;
      }

      const K = BARREL_K;
      const slices = clamp(Math.round(BARREL_SLICES * (w / (900 * dpr))), 50, 140);

      const cx = w * 0.5;
      const cy = h * 0.5;
      const invCx = 1 / Math.max(1e-6, cx);
      const invCy = 1 / Math.max(1e-6, cy);

      dctx.setTransform(1, 0, 0, 1, 0, 0);
      dctx.clearRect(0, 0, w, h);

      const dx = w / slices;
      for (let i = 0; i < slices; i++) {
        const x0 = i * dx;
        const x1 = (i + 1) * dx;
        const xMid = (x0 + x1) * 0.5;

        const xNorm = (xMid - cx) * invCx;
        const s = 1 + K * (xNorm * xNorm);
        const invS = 1 / s;

        dctx.save();
        dctx.beginPath();
        dctx.rect(x0, 0, x1 - x0 + 0.5, h);
        dctx.clip();

        dctx.translate(0, cy);
        dctx.scale(1, invS);
        dctx.translate(0, -cy);

        dctx.drawImage(renderCanvas, 0, 0);
        dctx.restore();
      }

      viewCtx.setTransform(1, 0, 0, 1, 0, 0);
      viewCtx.clearRect(0, 0, w, h);

      const dy = h / slices;
      for (let i = 0; i < slices; i++) {
        const y0 = i * dy;
        const y1 = (i + 1) * dy;
        const yMid = (y0 + y1) * 0.5;

        const yNorm = (yMid - cy) * invCy;
        const s = 1 + K * (yNorm * yNorm);
        const invS = 1 / s;

        viewCtx.save();
        viewCtx.beginPath();
        viewCtx.rect(0, y0, w, y1 - y0 + 0.5);
        viewCtx.clip();

        viewCtx.translate(cx, 0);
        viewCtx.scale(invS, 1);
        viewCtx.translate(-cx, 0);

        viewCtx.drawImage(distortCanvas, 0, 0);
        viewCtx.restore();
      }
    }

    // ============================================================
    // CRT pattern builder
    // ============================================================
    function ensureCrtPattern(w, h, dprLocal) {
      if (!crtImgReady) return null;

      const tileCssPx = Math.max(2, Math.round((w / dprLocal) / CRT_REPEATS_X));
      const shiftPx = Math.round(tileCssPx * CRT_BRICK_OFFSET_FRAC) % tileCssPx;

      if (crtPattern && tileCssPx === crtPatternTilePx && shiftPx === crtPatternShiftPx) return crtPattern;

      const tile = document.createElement('canvas');
      tile.width = tileCssPx;
      tile.height = tileCssPx;
      const tctx = tile.getContext('2d');
      tctx.clearRect(0, 0, tileCssPx, tileCssPx);
      tctx.drawImage(crtImg, 0, 0, tileCssPx, tileCssPx);

      const brick = document.createElement('canvas');
      brick.width = tileCssPx;
      brick.height = tileCssPx * 2;
      const bctx = brick.getContext('2d');
      bctx.clearRect(0, 0, brick.width, brick.height);
      bctx.drawImage(tile, 0, 0);
      bctx.drawImage(tile, -shiftPx, tileCssPx);
      bctx.drawImage(tile, tileCssPx - shiftPx, tileCssPx);

      const pat = ctx.createPattern(brick, 'repeat');
      crtPattern = pat;
      crtPatternTilePx = tileCssPx;
      crtPatternShiftPx = shiftPx;
      return pat;
    }

    function drawCrtOverlayIntoScene(w, h) {
      const pat = ensureCrtPattern(w, h, dpr);
      if (!pat) return;

      ctx.save();

      // Pattern blending + mild filtering
      ctx.filter = `contrast(${CRT_CONTRAST}) brightness(${CRT_BRIGHTNESS})`;
      ctx.globalCompositeOperation = CRT_COMPOSITE;
      ctx.globalAlpha = CRT_OPACITY;
      ctx.fillStyle = pat;

      // Align pattern to pixel grid (reduce shimmer)
      ctx.translate(0.5 * dpr, 0.5 * dpr);
      ctx.fillRect(-0.5 * dpr, -0.5 * dpr, w + dpr, h + dpr);

      ctx.restore();

      ctx.filter = 'none';
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }

    // ============================================================
    // Monkey neon cache
    // ============================================================
    function rebuildMonkeyCache(drawW, drawH) {
      const CACHE_SCALE = 2;
      const cw = Math.max(1, Math.round(drawW * CACHE_SCALE));
      const ch = Math.max(1, Math.round(drawH * CACHE_SCALE));

      monkeyCacheW = cw;
      monkeyCacheH = ch;

      monkeyMaskCanvas.width = cw;
      monkeyMaskCanvas.height = ch;
      monkeyLayerCanvas.width = cw;
      monkeyLayerCanvas.height = ch;

      const mctx = monkeyMaskCanvas.getContext('2d');
      mctx.setTransform(1, 0, 0, 1, 0, 0);
      mctx.clearRect(0, 0, cw, ch);
      mctx.drawImage(monkeyImg, 0, 0, cw, ch);
    }

    function ensureMonkeyCache(drawW, drawH) {
      if (!monkeyReady) return false;
      if (drawW !== monkeyCacheW || drawH !== monkeyCacheH) rebuildMonkeyCache(drawW, drawH);
      return true;
    }

    function makeTintedMonkeyLayer(colour, strokePxCss) {
      const lctx = monkeyLayerCanvas.getContext('2d');
      lctx.clearRect(0, 0, monkeyCacheW, monkeyCacheH);

      const strokePx = Math.max(0, strokePxCss * dpr);
      const half = Math.floor(strokePx / 2);

      lctx.globalCompositeOperation = 'source-over';
      for (let dx = -half; dx <= half; dx++) {
        for (let dy = -half; dy <= half; dy++) {
          lctx.drawImage(monkeyMaskCanvas, dx, dy);
        }
      }

      lctx.globalCompositeOperation = 'destination-in';
      lctx.drawImage(monkeyMaskCanvas, 0, 0);

      lctx.globalCompositeOperation = 'source-atop';
      lctx.fillStyle = colour;
      lctx.fillRect(0, 0, monkeyCacheW, monkeyCacheH);

      lctx.globalCompositeOperation = 'source-over';
    }

    function drawMonkeyNeon(x, y, tilt, drawW, drawH, extraScale = 1.0) {
      if (!ensureMonkeyCache(drawW, drawH)) return;

      const speedFactor = clamp(world.speed / world.baseSpeed, 1, 3.2);
      const tCap = clamp(world.survive / TAIL_X_CAP_S, 0, 1);

      const xNorm = clamp((speedFactor - 1) / (3.2 - 1), 0, 1) * tCap;
      const vNorm = clamp(Math.abs(tailVyFilt) / Math.max(1e-6, TAIL_VY_FOR_MAX), 0, 1);
      const ySign = (tailVyFilt >= 0) ? -1 : 1;

      const M_BLUE = 0.45;
      const M_GOLD = 0.70;
      const M_RED  = 1.00;

      const xLagBlue = -TAIL_X_MAX_CSS * xNorm * M_BLUE;
      const xLagGold = -TAIL_X_MAX_CSS * xNorm * M_GOLD;
      const xLagRed  = -TAIL_X_MAX_CSS * xNorm * M_RED;

      const yLagBlue = (TAIL_Y_MAX_CSS * vNorm * M_BLUE) * ySign;
      const yLagGold = (TAIL_Y_MAX_CSS * vNorm * M_GOLD) * ySign;
      const yLagRed  = (TAIL_Y_MAX_CSS * vNorm * M_RED ) * ySign;

      const goldOff = { x: (MONKEY_GOLD_OFF_CSS.x + xLagGold) * dpr, y: (MONKEY_GOLD_OFF_CSS.y + yLagGold) * dpr };
      const redOff  = { x: (MONKEY_RED_OFF_CSS.x  + xLagRed ) * dpr, y: (MONKEY_RED_OFF_CSS.y  + yLagRed ) * dpr };
      const blueOff = { x: (MONKEY_BLUE_OFF_CSS.x + xLagBlue) * dpr, y: (MONKEY_BLUE_OFF_CSS.y + yLagBlue) * dpr };
      const aquaOff = { x: MONKEY_AQUA_OFF_CSS.x * dpr, y: MONKEY_AQUA_OFF_CSS.y * dpr };

      const sBlue = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_BLUE;
      const sGold = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_GOLD;
      const sRed  = 1 + (TAIL_SCALE_MAX * xNorm + TAIL_SCALE_MAX * 0.75 * vNorm) * M_RED;

      const layers = [
        { colour: MONKEY_AQUA_COLOUR, blurCss: MONKEY_AURA_BLUR_PX, dx: aquaOff.x, dy: aquaOff.y, stroke: MONKEY_AQUA_STROKE_PX, mode: 'hard-light', scale: 1.0 },
        { colour: MONKEY_GOLD_COLOUR, blurCss: MONKEY_GLOW_BLUR_PX, dx: goldOff.x, dy: goldOff.y, stroke: MONKEY_GOLD_STROKE_PX, mode: 'normal',     scale: sGold },
        { colour: MONKEY_RED_COLOUR,  blurCss: MONKEY_GLOW_BLUR_PX, dx: redOff.x,  dy: redOff.y,  stroke: MONKEY_RED_STROKE_PX,  mode: 'normal',     scale: sRed  },
        { colour: MONKEY_BLUE_COLOUR, blurCss: MONKEY_GLOW_BLUR_PX, dx: blueOff.x, dy: blueOff.y, stroke: MONKEY_BLUE_STROKE_PX, mode: 'normal',     scale: sBlue },
        { colour: MONKEY_BASE_COLOUR, blurCss: 0,                   dx: 0,         dy: 0,          stroke: MONKEY_BASE_STROKE_PX, mode: 'normal',     scale: 1.0 },
      ];

      for (const L of layers) {
        makeTintedMonkeyLayer(L.colour, L.stroke);

        ctx.save();
        ctx.translate(x + L.dx, y + L.dy);
        ctx.rotate(tilt);

        const sLocal = (L.scale && L.scale !== 1) ? (L.scale * extraScale) : extraScale;
        if (sLocal !== 1) ctx.scale(sLocal, sLocal);

        ctx.filter = (L.blurCss > 0) ? `blur(${(L.blurCss * dpr).toFixed(4)}px)` : 'none';
        ctx.globalCompositeOperation = (L.mode === 'hard-light') ? 'hard-light' : 'source-over';

        if (L.colour === MONKEY_BASE_COLOUR) ctx.globalAlpha = MONKEY_BASE_ALPHA;
        else if (L.colour === MONKEY_AQUA_COLOUR) ctx.globalAlpha = MONKEY_AURA_ALPHA;
        else ctx.globalAlpha = MONKEY_GLOW_ALPHA;

        const passes = (L.colour === MONKEY_BASE_COLOUR) ? MONKEY_BASE_PASSES : 1;
        for (let i = 0; i < passes; i++) {
          ctx.drawImage(monkeyLayerCanvas, -drawW / 2, -drawH / 2, drawW, drawH);
        }

        ctx.restore();
      }

      ctx.globalAlpha = 1;
      ctx.filter = 'none';
      ctx.globalCompositeOperation = 'source-over';
    }

    // ============================================================
    // Collision
    // ============================================================
    const COLL_ROT_DEG = -24;
    const COLL_ROT = (COLL_ROT_DEG * Math.PI) / 180;
    const COLL_A_FRAC = 0.40;
    const COLL_B_FRAC = 0.15;
    const COLL_CX_OFF_FRAC = 0.05;
    const COLL_CY_OFF_FRAC = 0.03;

    function ellipseRectHit(cx, cy, a, b, theta, rx, ry, rw, rh) {
      const cosT = Math.cos(-theta);
      const sinT = Math.sin(-theta);

      function toEllipseSpace(x, y) {
        const dx = x - cx;
        const dy = y - cy;
        const ex = dx * cosT - dy * sinT;
        const ey = dx * sinT + dy * cosT;
        return { x: ex, y: ey };
      }
      function insideEllipse(ex, ey) {
        const nx = ex / a;
        const ny = ey / b;
        return (nx * nx + ny * ny) <= 1;
      }

      const corners = [
        [rx, ry],
        [rx + rw, ry],
        [rx, ry + rh],
        [rx + rw, ry + rh],
      ];
      for (const [x, y] of corners) {
        const p = toEllipseSpace(x, y);
        if (insideEllipse(p.x, p.y)) return true;
      }

      const closestX = clamp(cx, rx, rx + rw);
      const closestY = clamp(cy, ry, ry + rh);
      const q = toEllipseSpace(closestX, closestY);
      if (insideEllipse(q.x, q.y)) return true;

      const samplesPerEdge = 3;
      for (let i = 1; i <= samplesPerEdge; i++) {
        const t = i / (samplesPerEdge + 1);

        let sx = rx + t * rw, sy = ry;
        let p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx + t * rw; sy = ry + rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx; sy = ry + t * rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx + rw; sy = ry + t * rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;
      }

      return false;
    }

    function cssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function drawEllipseDebug(cx, cy, a, b, theta) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(theta);

      ctx.globalAlpha = 0.18;
      ctx.fillStyle = DEBUG_COLL_COLOUR;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2 * dpr;
      ctx.strokeStyle = DEBUG_COLL_COLOUR;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(-a, 0);
      ctx.lineTo(a, 0);
      ctx.stroke();

      ctx.restore();
    }

    // ============================================================
    // Game state (physics/mechanics unchanged)
    // ============================================================
    const player = { x: 0, y: 0, vy: 0, tilt: 0 };

    const world = {
      started: false,
      over: false,
      hasStartedOnce: false,

      survive: 0,
      playT: 0,
      baseSpeed: 180,
      speed: 180,
      groundPad: 22,
      topPad: 22,
      distAcc: 0,
      nextSpawnDist: 760,
      obstacles: [],
      nextRestAt: REST_EVERY_S,
      restPending: false,
      resting: false,
      returning: false,
      restT: 0,
      returnT: 0,
      restScale: 1,
      restUiAlpha: 0,

      helpOpen: false
    };

    const G = 2200;
    const K_BASE = 30;
    const K_BOOST = 1.2;
    const DAMP_BASE = 22;
    const VTERM = 2400;

    const G_FALL_SCALE_MIN = 0.02;
    const G_FALL_CC_MAX = 100;

    // ============================================================
    // CC2 + pulse gating (ALWAYS 3 pulses, as requested)
    // ============================================================
    let cc2 = 0;
    function setCC2(v) { cc2 = clamp(v | 0, 0, 127); }

    const PULSE_THRESHOLD = 32;
    const PULSE_WINDOW_S = 1.6;

    let prevCC2 = 0;
    let pulseCount = 0;
    let pulseWindowT = 0;

    function resetPulses() {
      pulseCount = 0;
      pulseWindowT = 0;
      prevCC2 = cc2;
    }

    function registerPulse(dt) {
      if (!currentInput) {
        resetPulses();
        return;
      }

      const rising = (prevCC2 < PULSE_THRESHOLD) && (cc2 >= PULSE_THRESHOLD);
      prevCC2 = cc2;

      if (pulseWindowT > 0) {
        pulseWindowT = Math.max(0, pulseWindowT - dt);
        if (pulseWindowT === 0) pulseCount = 0;
      }

      if (rising) {
        if (pulseWindowT === 0) {
          pulseWindowT = PULSE_WINDOW_S;
          pulseCount = 1;
        } else {
          pulseCount += 1;
        }

        if (pulseCount >= 3) {
          pulseCount = 0;
          pulseWindowT = 0;

          if (!world.started && !world.over) startGame();
          else if (world.over) startGame();
        }
      }
    }

    // ============================================================
    // Obstacles (unchanged)
    // ============================================================
    function spawnObstacle(w, h) {
      const groundY = computeGroundY(w, h);
      const ceilingY = world.topPad;

      const gap = 150;
      const kind = (Math.random() < 0.55) ? 'pipe' : 'block';
      const vx = world.speed * dpr;

      if (kind === 'pipe') {
        const pipeW = 56 * dpr;
        const gapCentreMin = ceilingY + 90 * dpr;
        const gapCentreMax = groundY - 90 * dpr;
        const gapCentre = clamp(
          Math.round(gapCentreMin + Math.random() * (gapCentreMax - gapCentreMin)),
          gapCentreMin, gapCentreMax
        );

        const topH = Math.max(20 * dpr, Math.round((gapCentre - (gap * dpr) / 2) - ceilingY));
        const botY = Math.round(gapCentre + (gap * dpr) / 2);
        const botH = Math.max(20 * dpr, Math.round(groundY - botY));

        world.obstacles.push({
          kind: 'pipe',
          x: w + 20 * dpr,
          w: pipeW,
          vx,
          top: { y: ceilingY, w: pipeW, h: topH },
          bot: { y: botY,     w: pipeW, h: botH }
        });
      } else {
        const blockW = Math.round((46 + Math.random() * 46) * dpr);
        const blockH = Math.round((50 + Math.random() * 140) * dpr);
        world.obstacles.push({
          kind: 'block',
          x: w + 20 * dpr,
          y: groundY - blockH,
          w: blockW,
          h: blockH,
          vx
        });
      }
    }

    // ============================================================
    // On-CRT UI drawing helpers
    // ============================================================
    const UI_BOTTOM_BAND_PX = 56; // CSS px reserved for bottom controls

    const ui = {
      musicRect: null,
      helpRect: null,
      backRect: null
    };

    function uiScalePx() {
      return clamp((renderCanvas.width / dpr) / 980, 0.90, 1.10);
    }

    function computeGroundY(w, h) {
      const s = uiScalePx();
      const m = Math.round(10 * s * dpr);
      const by = h - m - Math.round(26 * s * dpr);

      const groundYPhys = h - world.groundPad;
      const groundYUiCap = by - Math.round(10 * s * dpr);

      return Math.min(groundYPhys, groundYUiCap);
    }

    function roundRectPath(c, x, y, w, h, r) {
      const rr = Math.min(r, w * 0.5, h * 0.5);
      c.beginPath();
      c.moveTo(x + rr, y);
      c.arcTo(x + w, y, x + w, y + h, rr);
      c.arcTo(x + w, y + h, x, y + h, rr);
      c.arcTo(x, y + h, x, y, rr);
      c.arcTo(x, y, x + w, y, rr);
      c.closePath();
    }

    function drawPillAt(x, y, w, h, fillAlpha = 0.28, borderAlpha = 0.40) {
      ctx.save();
      ctx.globalAlpha = fillAlpha;
      ctx.fillStyle = 'rgba(0,0,0,1)';
      roundRectPath(ctx, x, y, w, h, 999 * dpr);
      ctx.fill();

      ctx.globalAlpha = borderAlpha;
      ctx.strokeStyle = cssVar('--border');
      ctx.lineWidth = Math.max(1, Math.round(1 * dpr));
      ctx.stroke();
      ctx.restore();
    }

    function pillMetrics(text, fontPx, padX, padY) {
      ctx.save();
      ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
      const tw = Math.ceil(ctx.measureText(text).width);
      ctx.restore();
      const h = Math.round(fontPx + padY * 2);
      const w = tw + padX * 2;
      return { w, h };
    }

    function drawTextPill(x, y, text, opts = {}) {
      const s = uiScalePx();
      const padX = Math.round(10 * s * dpr);
      const padY = Math.round(6 * s * dpr);
      const fontPx = Math.round((12 * s) * dpr);

      const { w, h } = pillMetrics(text, fontPx, padX, padY);
      drawPillAt(x, y, w, h, opts.alpha ?? 0.28, opts.borderAlpha ?? 0.40);

      ctx.save();
      ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'left';
      ctx.globalAlpha = opts.textAlpha ?? 0.90;
      ctx.fillStyle = opts.colour ?? cssVar('--muted');
      ctx.fillText(text, x + padX, y + Math.round(h * 0.5));
      ctx.restore();

      return { x, y, w, h };
    }

    function drawCircleButton(cx, cy, r, opts = {}) {
      ctx.save();
      ctx.globalAlpha = opts.alpha ?? 0.90;
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = opts.borderAlpha ?? 0.45;
      ctx.strokeStyle = cssVar('--border');
      ctx.lineWidth = Math.max(1, Math.round(1 * dpr));
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawSpeakerIcon(cx, cy, size, on) {
      // Minimal speaker glyph (no emoji) so it remains stylistically coherent.
      const s = size;
      const x = cx - s * 0.45;
      const y = cy - s * 0.35;

      ctx.save();
      ctx.globalAlpha = on ? 0.95 : 0.65;
      ctx.strokeStyle = on ? cssVar('--text') : cssVar('--muted');
      ctx.fillStyle = ctx.strokeStyle;
      ctx.lineWidth = Math.max(1, Math.round(1.6 * dpr));
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Speaker body (filled polygon)
      ctx.beginPath();
      ctx.moveTo(x, y + s * 0.25);
      ctx.lineTo(x + s * 0.22, y + s * 0.25);
      ctx.lineTo(x + s * 0.42, y + s * 0.10);
      ctx.lineTo(x + s * 0.42, y + s * 0.60);
      ctx.lineTo(x + s * 0.22, y + s * 0.45);
      ctx.lineTo(x, y + s * 0.45);
      ctx.closePath();
      ctx.fill();

      // Waves
      if (on) {
        ctx.beginPath();
        ctx.arc(x + s * 0.48, y + s * 0.35, s * 0.18, -0.55, 0.55);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x + s * 0.48, y + s * 0.35, s * 0.30, -0.55, 0.55);
        ctx.stroke();
      } else {
        // Muted X
        ctx.beginPath();
        ctx.moveTo(x + s * 0.54, y + s * 0.18);
        ctx.lineTo(x + s * 0.80, y + s * 0.52);
        ctx.moveTo(x + s * 0.80, y + s * 0.18);
        ctx.lineTo(x + s * 0.54, y + s * 0.52);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawGradientTitle(text, x, y, fontPx) {
      const g = ctx.createLinearGradient(x - fontPx * 2.0, y, x + fontPx * 2.0, y);
      g.addColorStop(0.0, cssVar('--accentA'));
      g.addColorStop(1.0, cssVar('--accentB'));

      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `900 ${fontPx}px Orbitron, system-ui, sans-serif`;

      // subtle glow
      ctx.globalAlpha = 0.20;
      ctx.shadowColor = cssVar('--accentA');
      ctx.shadowBlur = Math.round(14 * dpr);
      ctx.fillStyle = g;
      ctx.fillText(text, x, y);

      ctx.shadowColor = cssVar('--accentB');
      ctx.shadowBlur = Math.round(18 * dpr);
      ctx.fillText(text, x, y);

      // main
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 0.98;
      ctx.fillStyle = g;
      ctx.fillText(text, x, y);

      ctx.restore();
    }

    function drawHelpOverlay(w, h) {
      const s = uiScalePx();

      // === Transparency controls (adjust these) ===
      const HELP_DIM_ALPHA = 0.45;   // backdrop dim (0..1). Higher = darker background.
      const HELP_BOX_ALPHA = 0.92;   // panel opacity (0..1). Higher = more opaque panel.
      // ===========================================

      // Backdrop
      ctx.save();
      ctx.globalAlpha = HELP_DIM_ALPHA;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      ctx.restore();

      // Panel box
      const boxW = Math.round(w * 0.86);
      const boxH = Math.round(h * 0.68);
      const boxX = Math.round((w - boxW) * 0.5);
      const boxY = Math.round((h - boxH) * 0.5);
      const r = Math.round(16 * s * dpr);

      ctx.save();
      ctx.globalAlpha = HELP_BOX_ALPHA;
      ctx.fillStyle = 'rgba(0,0,0,0.78)';
      roundRectPath(ctx, boxX, boxY, boxW, boxH, r);
      ctx.fill();

      ctx.globalAlpha = 0.70;
      ctx.strokeStyle = cssVar('--border');
      ctx.lineWidth = Math.max(1, Math.round(1 * dpr));
      ctx.stroke();

      // Text metrics
      const pad = Math.round(18 * s * dpr);
      const x0 = boxX + pad;
      let y0 = boxY + pad;

      const titlePx = Math.round((14 * s) * dpr);
      const bodyPx  = Math.round((12 * s) * dpr);
      const lineH   = Math.round((18 * s) * dpr);

      const colText  = cssVar('--text');
      const colMuted = cssVar('--muted');

      function drawLine(text, opts = {}) {
        ctx.save();
        ctx.globalAlpha = opts.alpha ?? 0.92;
        ctx.fillStyle = opts.colour ?? colMuted;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.font = `${opts.weight ?? 400} ${opts.sizePx ?? bodyPx}px ${opts.family ?? '"JetBrains Mono", ui-monospace, monospace'}`;
        ctx.fillText(text, x0, y0);
        ctx.restore();
        y0 += (opts.advance ?? lineH);
      }

      // Title
      drawLine('Browser & MIDI Setup', {
        colour: colText,
        alpha: 0.95,
        weight: 900,
        sizePx: titlePx,
        family: 'Orbitron, system-ui, sans-serif',
        advance: Math.round(lineH * 1.1)
      });

      drawLine('Ventra uses WebMIDI. Support depends on browser.', {
        colour: colMuted,
        alpha: 0.90,
        advance: Math.round(lineH * 1.2)
      });

      // Bullet sections (Chrome/Firefox/Safari)
      const bullet = '• ';

      // Chrome / Edge
      drawLine(`${bullet}Chrome / Edge (recommended):`, { colour: colText, alpha: 0.92, weight: 800 });
      drawLine('WebMIDI works natively. Plug in Ventra and refresh if not detected.', {
        colour: colMuted, alpha: 0.92, advance: Math.round(lineH * 1.15)
      });

      // Firefox
      drawLine(`${bullet}Firefox:`, { colour: colText, alpha: 0.92, weight: 800 });

      drawLine('1) Close Firefox. Plug in Ventra. Reopen Firefox. (Otherwise Firefox may show no MIDI ports.)', { alpha: 0.92 });
      drawLine('2) When prompted, Allow MIDI device access (and SysEx if requested).', { alpha: 0.92 });
      drawLine('3) For music: click the speaker button once (autoplay is often blocked).', { alpha: 0.92 });

      drawLine('If MIDI still does not work: open about:config → set dom.webmidi.enabled to true → refresh.', {
        alpha: 0.92, advance: Math.round(lineH * 1.25)
      });

      // Safari
      drawLine(`${bullet}Safari (macOS):`, { colour: colText, alpha: 0.92, weight: 800 });
      drawLine('Develop → Experimental Features → enable WebMIDI. Restart browser if required.', {
        colour: colMuted, alpha: 0.92, advance: Math.round(lineH * 1.25)
      });

      // Controls
      drawLine('Controls:', { colour: colText, alpha: 0.92, weight: 800, advance: Math.round(lineH * 1.05) });
      drawLine('• Breath controls height via CC2.', { alpha: 0.92 });
      drawLine('• Start / restart: three breath pulses.', { alpha: 0.92, advance: Math.round(lineH * 1.15) });

      // Close hint
      drawLine('Click anywhere to close this help.', { colour: colMuted, alpha: 0.85 });

      ctx.restore();
    }

    // ============================================================
    // UI hit rectangles (scene-space, pre-barrel) in device pixels
    // ============================================================
    function rectHit(r, x, y) {
      if (!r) return false;
      return x >= r.x && x <= (r.x + r.w) && y >= r.y && y <= (r.y + r.h);
    }

    function clientToViewPx(evt) {
      const rect = canvas.getBoundingClientRect();
      const xCss = evt.clientX - rect.left;
      const yCss = evt.clientY - rect.top;
      return { x: xCss * dpr, y: yCss * dpr };
    }

    canvas.addEventListener('click', async (e) => {
      const { w, h } = resizeCanvasToDisplaySize();
      const v = clientToViewPx(e);
      const sxy = viewToScene(v.x, v.y, w, h);

      // Help open: click anywhere closes
      if (world.helpOpen) {
        world.helpOpen = false;
        return;
      }

      if (rectHit(ui.musicRect, sxy.x, sxy.y)) {
        setAudio(!audioOn);
        // If we turned ON, try to start immediately (interaction occurred)
        if (audioOn && world.started) await startMusicIfArmed();
        return;
      }

      if (rectHit(ui.helpRect, sxy.x, sxy.y)) {
        world.helpOpen = true;
        return;
      }

      if (rectHit(ui.backRect, sxy.x, sxy.y)) {
        window.location.href = './index.html';
        return;
      }
    });

    // ============================================================
    // Game lifecycle
    // ============================================================
    function resetGame() {
      const { w, h } = resizeCanvasToDisplaySize();

      world.started = false;
      world.over = false;

      world.survive = 0;
      world.playT = 0;
      world.speed = world.baseSpeed;

      world.distAcc = 0;
      world.obstacles = [];
      world.nextSpawnDist = 620;

      world.nextRestAt = REST_EVERY_S;
      world.restPending = false;
      world.resting = false;
      world.returning = false;
      world.restT = 0;
      world.returnT = 0;
      world.restScale = 1;
      world.restUiAlpha = 0;

      // Start screen: monkey waits centred.
      player.x = Math.round(w * 0.50);
      player.y = Math.round(h * 0.54);
      player.vy = 0;
      player.tilt = 0;

      tailVyFilt = 0;
      resetPulses();
    }

    function startGame() {
      if (!currentInput) return;

      if (world.over) resetGame();

      world.started = true;
      world.over = false;
      world.hasStartedOnce = true;

      const { w, h } = resizeCanvasToDisplaySize();
      player.x = Math.round(w * 0.22);
      player.y = Math.round(h * 0.50);
      player.vy = 0;
      player.tilt = 0;
      tailVyFilt = 0;

      resetPulses();
      startMusicIfArmed();
    }

    function gameOver() {
      world.over = true;
      world.started = false;

      resetPulses();
      stopMusic();

      world.restPending = false;
      world.resting = false;
      world.returning = false;
      world.restT = 0;
      world.returnT = 0;
      world.restScale = 1;
      world.restUiAlpha = 0;

      const { w, h } = resizeCanvasToDisplaySize();
      player.x = Math.round(w * 0.50);
      player.y = Math.round(h * 0.54);
      player.vy = 0;
      player.tilt = 0;
      tailVyFilt = 0;
    }

    // ============================================================
    // Drawing
    // ============================================================
    const GLASS_STRENGTH = 1.0;   // 0..2 (visual)
    const GLASS_VIGNETTE = 0.9;   // 0..1
    const GLASS_HIGHLIGHT = 0.8;  // 0..1

    function drawGlassShading(w, h) {
      if (GLASS_STRENGTH <= 0) return;

      ctx.save();

      // Highlight (soft-light style approximation using screen/overlay-ish)
      ctx.globalAlpha = 0.18 * GLASS_STRENGTH * GLASS_HIGHLIGHT;
      ctx.globalCompositeOperation = 'screen';
      let g = ctx.createRadialGradient(w * 0.50, h * 0.10, 0, w * 0.50, h * 0.10, Math.max(w, h) * 0.9);
      g.addColorStop(0.00, 'rgba(255,255,255,0.55)');
      g.addColorStop(0.35, 'rgba(255,255,255,0.12)');
      g.addColorStop(0.60, 'rgba(255,255,255,0.00)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      // Vignette (edge darkening)
      ctx.globalAlpha = 0.55 * GLASS_STRENGTH * GLASS_VIGNETTE;
      ctx.globalCompositeOperation = 'multiply';
      g = ctx.createRadialGradient(w * 0.50, h * 0.55, Math.min(w, h) * 0.35, w * 0.50, h * 0.55, Math.max(w, h) * 0.75);
      g.addColorStop(0.00, 'rgba(0,0,0,0.00)');
      g.addColorStop(1.00, 'rgba(0,0,0,0.85)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      ctx.restore();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
    }

    function drawScene(w, h) {
      ctx.clearRect(0, 0, w, h);

      const border = cssVar('--border');
      const accentA = cssVar('--accentA');
      const accentB = cssVar('--accentB');
      const text = cssVar('--text');
      const muted = cssVar('--muted');

      // Background remains black; add subtle vignette
      ctx.save();
      const v = ctx.createRadialGradient(w * 0.5, h * 0.5, Math.min(w, h) * 0.10, w * 0.5, h * 0.5, Math.min(w, h) * 0.80);
      v.addColorStop(0.0, 'rgba(0,0,0,0.00)');
      v.addColorStop(1.0, 'rgba(0,0,0,0.55)');
      ctx.fillStyle = v;
      ctx.fillRect(0, 0, w, h);
      ctx.restore();

      // Bottom UI placement (used to avoid the ground line cutting through buttons)
      const s = uiScalePx();
      const m = Math.round(10 * s * dpr);
      const by = h - m - Math.round(26 * s * dpr);
      
      // Physics ground (unchanged)
      const groundYPhys = h - world.groundPad;

      // Visual ground line: keep it ABOVE the bottom controls
      const groundYDraw = computeGroundY(w, h);

      // Draw ground line
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = border;
      ctx.lineWidth = 2 * dpr;
      ctx.beginPath();
      ctx.moveTo(0, groundYDraw + 1);
      ctx.lineTo(w, groundYDraw + 1);
      ctx.stroke();
      ctx.restore();

      // Obstacles
      for (const ob of world.obstacles) {
        if (ob.kind === 'pipe') {
          ctx.fillStyle = accentA;
          ctx.fillRect(ob.x, ob.top.y, ob.top.w, ob.top.h);
          ctx.fillStyle = accentB;
          ctx.fillRect(ob.x, ob.bot.y, ob.bot.w, ob.bot.h);

          ctx.strokeStyle = border;
          ctx.lineWidth = 1 * dpr;
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.top.y + 0.5 * dpr, ob.top.w - 1 * dpr, ob.top.h - 1 * dpr);
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.bot.y + 0.5 * dpr, ob.bot.w - 1 * dpr, ob.bot.h - 1 * dpr);
        } else {
          ctx.fillStyle = accentA;
          ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
          ctx.strokeStyle = border;
          ctx.lineWidth = 1 * dpr;
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.y + 0.5 * dpr, ob.w - 1 * dpr, ob.h - 1 * dpr);
        }
      }

      // Player
      const drawW = MONKEY_DRAW_W * dpr;
      const drawH = MONKEY_DRAW_H * dpr;

      if (monkeyReady) {
        const sLocal = (world.resting || world.returning) ? world.restScale : 1;
        drawMonkeyNeon(player.x, player.y, player.tilt, drawW, drawH, sLocal);
      } else {
        ctx.save();
        ctx.fillStyle = text;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 14 * dpr, 0, Math.PI * 2);
        ctx.fill();

        const pct = cc2 / 127;
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = (pct > 0.01) ? cssVar('--warn') : muted;
        ctx.beginPath();
        ctx.arc(player.x, player.y, Math.max(3 * dpr, Math.round(14 * dpr * (0.25 + 0.35 * pct))), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // =========================
      // On-CRT UI (NO duplication)
      // =========================
      const topY = m;

      const ventraText = (!('requestMIDIAccess' in navigator))
        ? 'Ventra not supported in this browser'
        : (currentInput ? 'Ventra connected' : 'Ventra not connected — plug in and refresh');

      const left = drawTextPill(m, topY, ventraText, { colour: currentInput ? cssVar('--text') : cssVar('--muted'), alpha: 0.28 });

      const ccText = `CC2: ${String(cc2).padStart(3, '0')}`;
      // measure-first for right aligned (no redraw)
      {
        const s2 = uiScalePx();
        const padX = Math.round(10 * s2 * dpr);
        const padY = Math.round(6 * s2 * dpr);
        const fontPx = Math.round((12 * s2) * dpr);
        const { w: pillW, h: pillH } = pillMetrics(ccText, fontPx, padX, padY);
        const x = w - m - pillW;
        drawPillAt(x, topY, pillW, pillH, 0.28, 0.40);

        ctx.save();
        ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'left';
        ctx.globalAlpha = 0.90;
        ctx.fillStyle = cssVar('--muted');
        ctx.fillText(ccText, x + padX, topY + Math.round(pillH * 0.5));
        ctx.restore();
      }

      // HUD (time/speed) on the right during play
      if (world.started && !world.over) {
        const t1 = `Time: ${world.survive.toFixed(1)} s`;
        const t2 = `Speed: ${world.speed.toFixed(0)}`;
        const hudY = topY + Math.round(32 * s * dpr);

        // time
        {
          const s2 = uiScalePx();
          const padX = Math.round(10 * s2 * dpr);
          const padY = Math.round(6 * s2 * dpr);
          const fontPx = Math.round((12 * s2) * dpr);
          const { w: pillW, h: pillH } = pillMetrics(t1, fontPx, padX, padY);
          const x = w - m - pillW;
          drawPillAt(x, hudY, pillW, pillH, 0.22, 0.30);
          ctx.save();
          ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'left';
          ctx.globalAlpha = 0.80;
          ctx.fillStyle = cssVar('--muted');
          ctx.fillText(t1, x + padX, hudY + Math.round(pillH * 0.5));
          ctx.restore();
        }

        // speed
        {
          const s2 = uiScalePx();
          const padX = Math.round(10 * s2 * dpr);
          const padY = Math.round(6 * s2 * dpr);
          const fontPx = Math.round((12 * s2) * dpr);
          const { w: pillW, h: pillH } = pillMetrics(t2, fontPx, padX, padY);
          const y = hudY + Math.round(28 * s * dpr);
          const x = w - m - pillW;
          drawPillAt(x, y, pillW, pillH, 0.22, 0.30);
          ctx.save();
          ctx.font = `${fontPx}px "JetBrains Mono", ui-monospace, monospace`;
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'left';
          ctx.globalAlpha = 0.80;
          ctx.fillStyle = cssVar('--muted');
          ctx.fillText(t2, x + padX, y + Math.round(pillH * 0.5));
          ctx.restore();
        }
      }

      // Bottom controls: Back pill + Help circle + Speaker circle
      // Back pill
      const back = drawTextPill(m, by, 'Back', { colour: cssVar('--muted'), alpha: 0.28 });
      ui.backRect = back;

      // Help circle (right)
      const rBtn = Math.round(13 * s * dpr);
      const helpCx = w - m - rBtn;
      const helpCy = by + rBtn;
      drawCircleButton(helpCx, helpCy, rBtn, { alpha: 0.90, borderAlpha: 0.45 });
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = cssVar('--text');
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `900 ${Math.round(14 * s * dpr)}px Orbitron, system-ui, sans-serif`;
      ctx.fillText('?', helpCx, helpCy + Math.round(0.5 * dpr));
      ctx.restore();
      ui.helpRect = { x: helpCx - rBtn, y: helpCy - rBtn, w: rBtn * 2, h: rBtn * 2 };

      // Speaker circle (left of help)
      const spCx = helpCx - Math.round((2 * rBtn + 10 * s * dpr));
      const spCy = helpCy;
      drawCircleButton(spCx, spCy, rBtn, { alpha: 0.90, borderAlpha: 0.45 });
      drawSpeakerIcon(spCx, spCy, Math.round(18 * s * dpr), audioOn);
      ui.musicRect = { x: spCx - rBtn, y: spCy - rBtn, w: rBtn * 2, h: rBtn * 2 };

      // Start screen title + instruction
      if (!world.started && !world.over) {
        const bigPx = Math.round((40 * s) * dpr);
        const smallPx = Math.round((16 * s) * dpr);

        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `900 ${smallPx}px Orbitron, system-ui, sans-serif`;
        ctx.globalAlpha = 0.70;
        ctx.fillStyle = muted;
        ctx.fillText('VENTRA', Math.round(w * 0.5), Math.round(h * 0.205));
        ctx.restore();

        drawGradientTitle('EXHALE//ASCEND', Math.round(w * 0.5), Math.round(h * 0.26), bigPx);

        const msg = currentInput
          ? 'Start with three breath pulses'
          : 'Plug in Ventra, refresh, then start';

        const prog = currentInput
          ? `Pulses: ${String(pulseCount).padStart(1, '0')} / 3`
          : 'Waiting for MIDI device…';

        ctx.save();
        const tPx = Math.round((12 * s) * dpr);
        ctx.font = `${tPx}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.fillStyle = muted;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.92;
        ctx.fillText(msg, Math.round(w * 0.5), Math.round(h * 0.34));
        ctx.globalAlpha = 0.75;
        ctx.fillText(prog, Math.round(w * 0.5), Math.round(h * 0.38));
        ctx.restore();
      }

      // Game-over overlay
      if (world.over) {
        const s2 = uiScalePx();
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        ctx.font = `900 ${Math.round(26 * s2 * dpr)}px Orbitron, system-ui, sans-serif`;
        ctx.fillStyle = text;
        ctx.globalAlpha = 0.92;
        ctx.fillText('GAME OVER', Math.round(w * 0.5), Math.round(h * 0.26));

        ctx.font = `${Math.round(12 * s2 * dpr)}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.fillStyle = muted;
        ctx.globalAlpha = 0.88;
        ctx.fillText(`Survived: ${world.survive.toFixed(1)} s`, Math.round(w * 0.5), Math.round(h * 0.34));
        ctx.fillText('Restart with three breath pulses', Math.round(w * 0.5), Math.round(h * 0.38));
        ctx.restore();
      }

      // Breath phase overlay (unchanged)
      if (world.started && (world.resting || world.returning)) {
        const aUi = clamp(world.restUiAlpha, 0, 1);
        if (aUi > 0) {
          ctx.save();
          ctx.globalAlpha = REST_DIM_ALPHA * aUi;
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, w, h);
          ctx.restore();

          const dur = restDurationS();
          const u = clamp(world.restT / Math.max(1e-6, dur), 0, 1);
          const stepU = 1 / REST_COUNT;
          const idx = clamp(Math.floor(u / stepU), 0, REST_COUNT - 1);
          const countVal = Math.max(1, REST_COUNT - idx);

          ctx.save();
          ctx.globalAlpha = 0.92 * aUi;
          ctx.fillStyle = text;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          ctx.font = `${Math.round(18 * dpr)}px Orbitron, system-ui, sans-serif`;
          ctx.fillText('Breathe', Math.round(w * 0.5), Math.round(h * 0.42));

          ctx.font = `${Math.round(30 * dpr)}px Orbitron, system-ui, sans-serif`;
          ctx.fillText(String(countVal), Math.round(w * 0.5), Math.round(h * 0.50));

          ctx.font = `${Math.round(12 * dpr)}px "JetBrains Mono", ui-monospace, monospace`;
          ctx.globalAlpha = 0.78 * aUi;
          ctx.fillText('Control paused', Math.round(w * 0.5), Math.round(h * 0.58));
          ctx.restore();
        }
      }

      if (world.started && world.restPending && !world.resting && !world.returning) {
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = text;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.font = `${Math.round(11 * dpr)}px "JetBrains Mono", ui-monospace, monospace`;
        ctx.fillText('Clearing…', Math.round(w - 10 * dpr), Math.round(h - 44 * dpr));
        ctx.restore();
      }

      if (world.helpOpen) drawHelpOverlay(w, h);

      // Glass shading (curved-glass highlight + vignette), then CRT pattern on top
      drawGlassShading(w, h);
      
      // CRT overlay MUST be drawn last so it sits over everything (title, UI, game)
      drawCrtOverlayIntoScene(w, h);

      if (SHOW_COLLISION_DEBUG) {
        const a = Math.max(8 * dpr, (drawW * COLL_A_FRAC));
        const b = Math.max(6 * dpr, (drawH * COLL_B_FRAC));
        const theta = COLL_ROT + (COLL_FOLLOWS_SPRITE_TILT ? player.tilt : 0);

        const cx = player.x + (drawW * COLL_CX_OFF_FRAC);
        const cy = player.y + (drawH * COLL_CY_OFF_FRAC);

        drawEllipseDebug(cx, cy, a, b, theta);
      }
    }

    // ============================================================
    // Main loop (physics/mechanics unchanged)
    // ============================================================
    let lastTs = 0;

    function step(ts) {
      const { w, h } = resizeCanvasToDisplaySize();

      const dt = Math.min(0.033, Math.max(0.001, (ts - (lastTs || ts)) / 1000));
      lastTs = ts;

      // If Ventra disappears mid-run: stop play and return to start screen.
      if (!currentInput) {
        setCC2(0);
        if (world.started) {
          world.started = false;
          world.over = false;
          stopMusic();
          resetPulses();
          tailVyFilt = 0;

          world.restPending = false;
          world.resting = false;
          world.returning = false;
          world.restT = 0;
          world.returnT = 0;
          world.restScale = 1;
          world.restUiAlpha = 0;

          player.x = Math.round(w * 0.50);
          player.y = Math.round(h * 0.54);
          player.vy = 0;
          player.tilt = 0;
        }
      }

      registerPulse(dt);

      const groundY = computeGroundY(w, h);
      const ceilingY = world.topPad;

      if (world.started && !world.over) {
        const inBreak = (world.resting || world.returning);

        world.survive += dt;
        if (!inBreak) world.playT += dt;

        const targetSpeed = world.baseSpeed + SPEED_RAMP_PER_S * world.playT;
        world.speed = expApproach(world.speed, targetSpeed, dt, SPEED_TAU_S);

        if (!world.restPending && !inBreak && world.playT >= world.nextRestAt) {
          world.restPending = true;
        }

        for (const ob of world.obstacles) {
          const vx = (typeof ob.vx === 'number') ? ob.vx : (world.speed * dpr);
          ob.x -= vx * dt;
        }

        while (world.obstacles.length && (world.obstacles[0].x + (world.obstacles[0].w || world.obstacles[0].top.w)) < -40 * dpr) {
          world.obstacles.shift();
        }

        if (world.restPending && !inBreak && world.obstacles.length === 0) {
          world.restPending = false;
          world.resting = true;
          world.returning = false;
          world.restT = 0;
          world.returnT = 0;
          world.restScale = REST_FLYIN_SCALE_FROM;
          world.restUiAlpha = 1;
          world.distAcc = 0;
          player.vy = 0;
          player.tilt = 0;
          tailVyFilt = 0;
        }

        if (world.resting) {
          world.restT += dt;

          const dur = restDurationS();
          const u = clamp(world.restT / Math.max(1e-6, dur), 0, 1);

          const centreX = Math.round(w * REST_CENTRE_X_FRAC);
          const centreY = Math.round(h * REST_CENTRE_Y_FRAC);

          player.x = expApproach(player.x, centreX, dt, REST_MOVE_TAU_S);
          player.y = expApproach(player.y, centreY, dt, REST_MOVE_TAU_S);

          player.vy = 0;
          player.tilt = 0;

          const flyU = clamp(u / Math.max(1e-6, REST_FLYIN_FRACTION), 0, 1);
          const baseScale = REST_FLYIN_SCALE_FROM + (REST_BASE_SCALE - REST_FLYIN_SCALE_FROM) * flyU;

          const phase = u * REST_PULSES * Math.PI * 2;
          const pulse01 = 0.5 - 0.5 * Math.cos(phase);
          world.restScale = baseScale * (1 + REST_PULSE_SCALE * pulse01);

          tailVyFilt = expApproach(tailVyFilt, 0, dt, 0.06);

          if (world.restT >= dur) {
            world.restT = dur;
            world.resting = false;
            world.returning = true;
            world.returnT = 0;
            world.restUiAlpha = 1;

            player.vy = 0;
            player.tilt = 0;
            tailVyFilt = 0;

            world.nextRestAt += REST_EVERY_S;
          }
        }

        if (world.returning) {
          world.returnT += dt;

          const dur = restDurationS();
          const returnS = Math.max(0.05, dur * REST_RETURN_FRACTION);

          const laneX = Math.round(w * 0.22);
          const centreY = Math.round(h * REST_CENTRE_Y_FRAC);

          world.restUiAlpha = clamp(1 - (world.returnT / Math.max(1e-6, REST_UI_FADE_S)), 0, 1);

          player.x = expApproach(player.x, laneX, dt, REST_RETURN_TAU_S);
          player.y = expApproach(player.y, centreY, dt, REST_RETURN_TAU_S);

          world.restScale = expApproach(world.restScale, 1, dt, REST_RETURN_TAU_S);

          player.vy = 0;
          player.tilt = 0;
          tailVyFilt = expApproach(tailVyFilt, 0, dt, 0.06);

          if (world.returnT >= returnS) {
            world.returning = false;
            world.returnT = 0;
            world.restUiAlpha = 0;
            world.restScale = 1;

            player.x = laneX;
            player.vy = 0;
            player.tilt = 0;
            tailVyFilt = 0;

            world.distAcc = 0;
          }
        }

        if (!world.resting && !world.returning) {
          const pct = cc2 / 127;
          const maxLift = (groundY - 14 * dpr) - (ceilingY + 14 * dpr);
          const targetY = (groundY - 14 * dpr) - (pct * maxLift);

          const speedFactor = clamp(world.speed / world.baseSpeed, 1, 3.2);
          const K = K_BASE * (1 + K_BOOST * (speedFactor - 1));
          const DAMP = DAMP_BASE * (0.95 + 0.25 * (speedFactor - 1));

          const speedFade = clamp((speedFactor - 1) / (3.2 - 1), 0, 1);
          const ccFade = clamp(cc2 / G_FALL_CC_MAX, 0, 1);
          const fallScale = (G_FALL_SCALE_MIN + (1 - G_FALL_SCALE_MIN) * ccFade);
          const gEff = G * (fallScale + (1 - fallScale) * speedFade);

          let ay = (K * (targetY - player.y)) - (DAMP * player.vy) + gEff;

          player.vy += ay * dt;
          player.vy = clamp(player.vy, -VTERM * dpr, VTERM * dpr);
          player.y += player.vy * dt;

          {
            const alpha = 1 - Math.exp(-dt / Math.max(1e-6, TAIL_VY_TAU_S));
            tailVyFilt = tailVyFilt + alpha * (player.vy - tailVyFilt);
          }

          player.tilt = clamp(-player.vy / (900 * dpr), -0.20, 0.20);

          const floorY = groundY - 14 * dpr;
          if (player.y > floorY) { player.y = floorY; if (player.vy > 0) player.vy = 0; }
          const ceilY = ceilingY + 14 * dpr;
          if (player.y < ceilY) { player.y = ceilY; if (player.vy < 0) player.vy = 0; }

          const t = world.playT;
          const startMean = 760 * dpr;
          const endMean = 560 * dpr;
          const ease = clamp(t / 18, 0, 1);
          const mean = startMean + (endMean - startMean) * ease;
          const jitter = 0.18;

          world.distAcc += (world.speed * dpr) * dt;

          if (!world.restPending) {
            if (world.distAcc >= world.nextSpawnDist) {
              world.distAcc = 0;
              spawnObstacle(w, h);
              const r = (Math.random() * 2 - 1) * jitter;
              world.nextSpawnDist = Math.max(420 * dpr, mean * (1 + r));
            }
          } else {
            world.distAcc = Math.min(world.distAcc, world.nextSpawnDist - 0.001);
          }

          const drawW = MONKEY_DRAW_W * dpr;
          const drawH = MONKEY_DRAW_H * dpr;
          const a = Math.max(8 * dpr, (drawW * COLL_A_FRAC));
          const b = Math.max(6 * dpr, (drawH * COLL_B_FRAC));
          const collTheta = COLL_ROT + (COLL_FOLLOWS_SPRITE_TILT ? player.tilt : 0);

          const cx = player.x + (drawW * COLL_CX_OFF_FRAC);
          const cy = player.y + (drawH * COLL_CY_OFF_FRAC);

          for (const ob of world.obstacles) {
            if (ob.kind === 'pipe') {
              if (
                ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.top.y, ob.top.w, ob.top.h) ||
                ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.bot.y, ob.bot.w, ob.bot.h)
              ) { gameOver(); break; }
            } else {
              if (ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.y, ob.w, ob.h)) {
                gameOver(); break;
              }
            }
          }
        }
      } else {
        player.tilt = 0;
        tailVyFilt *= 0.90;
        world.restScale = 1;
        world.restUiAlpha = 0;

        if (!world.over) {
          const cx = Math.round(w * 0.50);
          const cy = Math.round(h * 0.54);
          player.x = expApproach(player.x, cx, dt, 0.12);
          player.y = expApproach(player.y, cy, dt, 0.12);
        }
      }

      drawScene(w, h);
      presentWithBarrel(w, h);

      requestAnimationFrame(step);
    }

    function onMIDIMessage(e) {
      const data = e.data;
      if (!data || data.length < 3) return;

      const status = data[0];
      const type = status & 0xF0;

      const targetStatus = 0xB0 | ((targetChannel1Based - 1) & 0x0F);
      if (type === 0xB0 && status === targetStatus && data[1] === targetCC) {
        setCC2(data[2]);
      }
    }

    // ============================================================
    // Boot
    // ============================================================
    resetGame();
    setCC2(0);
    requestAnimationFrame(step);
  </script>
</body>
</html>