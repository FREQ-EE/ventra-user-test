<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ventra · Side-scroller (WebMIDI)</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;800;900&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root { color-scheme: dark light; }

    :root{
      --bg:#0F1011; --card:#13151C; --text:#EDF4FA; --muted:#9AA4B2; --border:#262C3C;
      --accentA:#8B5CF6; --accentB:#EC4899; --warn:#FFB86B; --danger:#FF6B6B;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#FFFFFF; --card:#FFFFFF; --text:#0B0D10; --muted:#556170; --border:#E5E7EB;
        --accentA:#7C3AED; --accentB:#DB2777; --warn:#B86B00; --danger:#B42318;
      }
    }

    html, body { height: 100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:"JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      line-height:1.35;
    }

    .wrap{ max-width:980px; margin:0 auto; padding:18px 18px 28px; display:grid; gap:14px; }
    header{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap; }

    h1{
      margin:0;
      font-family:"Orbitron", system-ui, sans-serif;
      font-weight:900;
      font-size:18px;
      letter-spacing:0.02em;
      background:linear-gradient(90deg, var(--accentA), var(--accentB));
      -webkit-background-clip:text; background-clip:text; color:transparent;
    }
    .sub{ margin:0; color:var(--muted); font-size:12px; }

    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    a{ color:inherit; text-decoration:none; }
    a:hover{ text-decoration:underline; }

    .pill{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:rgba(0,0,0,0.10);
      font-size:12px;
      color:var(--muted);
      font-variant-numeric:tabular-nums;
      white-space:nowrap;
      user-select:none;
    }
    .pillStrong{ color:var(--text); }

    .pillButton{
      cursor:pointer;
      transition: border-color 120ms ease;
    }
    .pillButton:hover{ border-color:var(--accentA); }

    #ccPill { min-width: 86px; justify-content: center; }

    /* Small icon button in pill form */
    button{ font:inherit; color:inherit; }
    .iconBtn{
      border:1px solid var(--border);
      border-radius:999px;
      background:rgba(0,0,0,0.10);
      padding:6px 10px;
      cursor:pointer;
      display:inline-flex; align-items:center; gap:8px;
      color:var(--muted);
      transition: border-color 120ms ease, color 120ms ease;
    }
    .iconBtn:hover{ border-color:var(--accentA); color:var(--text); }
    .iconBtn svg{ width:18px; height:18px; }
    .iconBtn svg{ pointer-events:none; }
    .iconOn, .iconOff{ display:none; }
    .iconBtn[data-on="1"] .iconOn{ display:block; }
    .iconBtn[data-on="0"] .iconOff{ display:block; }

    /* Game */
    .gameShell{
      position:relative;
      overflow:hidden;
      border-radius:16px;
      border:1px solid var(--border);
      background:
        radial-gradient(900px 320px at 10% 0%, rgba(139,92,246,0.18), transparent 70%),
        radial-gradient(900px 320px at 90% 0%, rgba(236,72,153,0.15), transparent 70%),
        linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.00));
      height: 460px;
    }

    canvas{ display:block; width:100%; height:100%; }

    .hud{
      position:absolute; top:10px; left:10px; right:10px;
      display:flex; justify-content:space-between; gap:10px;
      pointer-events:none;
      font-size:12px;
      color:var(--muted);
    }
    .hudItem{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.10);
      white-space:nowrap;
      font-variant-numeric:tabular-nums;
    }

    .overlay{
      position:absolute; inset:0;
      display:grid; place-items:center;
      pointer-events:none;
      padding:18px;
      text-align:center;
    }
    .overlayBox{
      max-width:620px; width:100%;
      border-radius:16px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.16);
      padding:14px;
      box-shadow:0 10px 40px rgba(0,0,0,0.25);
    }
    .overlayTitle{
      font-family:"Orbitron", system-ui, sans-serif;
      font-weight:900;
      margin:0 0 8px;
      font-size:14px;
      letter-spacing:0.02em;
      color:var(--text);
    }
    .overlayText{ margin:0; font-size:12px; color:var(--muted); }
    .kbd{
      display:inline-block;
      padding:2px 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(0,0,0,0.10);
      color:var(--text);
      font-size:12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>VENTRA · SIDE-SCROLLER</h1>
      </div>

      <div class="row" aria-label="Status">
        <span class="pill pillButton" id="ventraPill" title="Click to enable WebMIDI">Ventra: click to enable</span>
        <span class="pill" id="ccPill">CC2: 000</span>

        <button class="iconBtn" id="audioToggle" type="button" data-on="0" aria-label="Toggle music" title="Toggle music">
          <!-- Speaker ON -->
          <svg class="iconOn" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M3 10v4h4l5 4V6L7 10H3zm13.5 2a3.5 3.5 0 0 0-1.5-2.9v5.8A3.5 3.5 0 0 0 16.5 12zm0-7a1 1 0 0 0-.7 1.7A8 8 0 0 1 18 12a8 8 0 0 1-2.2 5.3 1 1 0 1 0 1.4 1.4A10 10 0 0 0 20 12a10 10 0 0 0-2.8-6.7 1 1 0 0 0-.7-.3z"/>
          </svg>
          <!-- Speaker OFF -->
          <svg class="iconOff" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M3 10v4h4l5 4V6L7 10H3zm13.1 2 2.8 2.8 1.4-1.4L17.5 10.6l2.8-2.8-1.4-1.4L16.1 9.2l-2.8-2.8-1.4 1.4 2.8 2.8-2.8 2.8 1.4 1.4L16.1 12z"/>
          </svg>
        </button>

        <span class="pill"><a href="./index.html" title="Back to instructions & feedback">Back</a></span>
      </div>
    </header>

    <div class="gameShell" aria-label="Ventra game">
      <div class="hud">
        <div class="hudItem" id="hudTime">Time: 0.0 s</div>
        <div class="hudItem" id="hudSpeed">Speed: 0</div>
      </div>

      <canvas id="game"></canvas>

      <div class="overlay" id="overlay">
        <div class="overlayBox">
          <p class="overlayTitle" id="overlayTitle">Ready</p>
          <p class="overlayText" id="overlayText">
            Start with <span class="kbd">three breath pulses</span>.
            Backup: <span class="kbd">Space</span> or click.
            No device: hold <span class="kbd">↑</span> to simulate blowing.
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Music placeholder:
       Browsers do not reliably play .mid directly.
       Replace src with a rendered audio file (mp3/ogg) when ready. -->
  <audio id="bgm" loop preload="auto">
  <source src="./music.ogg" type="audio/ogg">
  <source src="./music.mp3" type="audio/mpeg">
  </audio>

  <script>
    'use strict';

    // ============================================================
    // Utility
    // ============================================================
    function clamp(n, lo, hi) { return Math.min(hi, Math.max(lo, n)); }

    // ============================================================
    // Debug toggles
    // ============================================================
    const SHOW_COLLISION_DEBUG = false;     // <- OFF
    const COLL_FOLLOWS_SPRITE_TILT = true;
    const DEBUG_COLL_COLOUR = '#00FFFF';

    // ============================================================
    // Asset: monkey SVG loaded as image (same folder as game.html)
    // ============================================================
    const monkeyImg = new Image();
    let monkeyReady = false;
    monkeyImg.onload = () => { monkeyReady = true; };
    monkeyImg.onerror = (e) => { console.warn('Failed to load monkey.svg', e); };
    monkeyImg.src = './monkey.svg';

    // Visual size (in CSS pixels mapped into canvas pixels by DPR)
    const MONKEY_DRAW_W = 150;
    const MONKEY_DRAW_H = 150;

    // Collision parameters
    const COLL_ROT_DEG = -24;
    const COLL_ROT = (COLL_ROT_DEG * Math.PI) / 180;
    const COLL_A_FRAC = 0.40;
    const COLL_B_FRAC = 0.15;
    const COLL_CX_OFF_FRAC = 0.05;
    const COLL_CY_OFF_FRAC = 0.03;

    // ============================================================
    // WebMIDI (Channel 1, CC2) - Ventra auto attach
    // ============================================================
    const targetChannel1Based = 1;
    const targetCC = 2;

    const ventraPill = document.getElementById('ventraPill');
    const ccPill = document.getElementById('ccPill');

    let midiAccess = null;
    let currentInput = null;

    function setVentraPill(text, clickable, title='') {
      ventraPill.textContent = text;
      ventraPill.title = title;
      ventraPill.classList.toggle('pillButton', !!clickable);
    }

    function detachCurrentInput() {
      if (currentInput) currentInput.onmidimessage = null;
      currentInput = null;
    }

    function findVentraInput() {
      if (!midiAccess) return null;
      const inputs = Array.from(midiAccess.inputs.values());
      const byName = inputs.find(i => (i.name || '').toLowerCase().includes('ventra'));
      return byName || null;
    }

    function attachVentraIfPresent() {
      detachCurrentInput();
      const input = findVentraInput();
      if (!input) {
        setVentraPill('Ventra: not connected (click to retry)', true, 'Click to retry Ventra detection');
        return false;
      }
      currentInput = input;
      currentInput.onmidimessage = onMIDIMessage;
      setVentraPill('Ventra: connected', false);
      return true;
    }

    async function enableMIDI() {
      if (!('requestMIDIAccess' in navigator)) {
        setVentraPill('Ventra: unsupported', false);
        return;
      }

      try {
        midiAccess = await navigator.requestMIDIAccess({ sysex: false });
        // Attempt immediate attach
        attachVentraIfPresent();

        // Watch hot-plug
        midiAccess.onstatechange = () => {
          // If already attached and still present, keep.
          // Otherwise re-scan and attach when Ventra appears.
          const want = findVentraInput();
          const have = currentInput && want && currentInput.id === want.id;
          if (!have) attachVentraIfPresent();
        };
      } catch (err) {
        console.error(err);
        setVentraPill('Ventra: permission denied', true);
      }
    }

    // WebMIDI generally requires a user gesture: we use the pill as the gesture target.
    ventraPill.addEventListener('click', () => {
      if (!midiAccess) enableMIDI();
      else attachVentraIfPresent(); // retry scan/attach
    });


    // Initial UI state
    setVentraPill('Ventra: click to enable', true, 'Click to enable WebMIDI');

    // ============================================================
    // Music toggle (simple audio loop)
    // ============================================================
    
    const audioToggle = document.getElementById('audioToggle');
    const bgm = document.getElementById('bgm');
    const AUDIO_KEY = 'ventra_game_music';

    function musicIsArmed() {
      return audioToggle.dataset.on === '1';
    }
    
    async function startMusicIfArmed() {
      if (!bgm) return;
      if (!musicIsArmed()) return;
      try {
        await bgm.play();
      } catch (e) {
        console.warn('Audio play failed:', e);
        // Keep UI state; user may need another gesture depending on browser policy.
      }
    }
    
    function stopMusic() {
      if (!bgm) return;
      bgm.pause();
      bgm.currentTime = 0;
    }
    
    function setAudioUI(on) {
      audioToggle.dataset.on = on ? '1' : '0';
    }

    async function setAudio(on) {
      localStorage.setItem(AUDIO_KEY, on ? '1' : '0');
      setAudioUI(on);

      if (!bgm) return;

      if (on) {
        // Do not start yet; start when the game starts.
        // If game is already running, we can start immediately:
        if (world && world.started) startMusicIfArmed();
      } else {
        stopMusic();
      }
    }

    // restore preference (does not auto-play reliably due to gesture rules)
    setAudioUI(localStorage.getItem(AUDIO_KEY) === '1');

    audioToggle.addEventListener('click', () => {
      const next = audioToggle.dataset.on !== '1';
      setAudio(next);
    });

    // ============================================================
    // Game
    // ============================================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const hudTime = document.getElementById('hudTime');
    const hudSpeed = document.getElementById('hudSpeed');

    // Input
    let cc2 = 0; // 0..127
    let simulateKey = false;

    function setCC2(v) {
      cc2 = clamp(v | 0, 0, 127);
      ccPill.textContent = `CC2: ${String(cc2).padStart(3, '0')}`;
    }

    // Primary start/restart: breath pulses
    const PULSE_THRESHOLD = 32;
    const PULSE_WINDOW_S = 1.6;
    let prevCC2 = 0;
    let pulseCount = 0;
    let pulseWindowT = 0;

    function resetPulses() {
      pulseCount = 0;
      pulseWindowT = 0;
      prevCC2 = cc2;
    }

    function registerPulse(dt) {
      const rising = (prevCC2 < PULSE_THRESHOLD) && (cc2 >= PULSE_THRESHOLD);
      prevCC2 = cc2;

      if (pulseWindowT > 0) {
        pulseWindowT = Math.max(0, pulseWindowT - dt);
        if (pulseWindowT === 0) pulseCount = 0;
      }

      if (rising) {
        if (pulseWindowT === 0) {
          pulseWindowT = PULSE_WINDOW_S;
          pulseCount = 1;
        } else {
          pulseCount += 1;
        }

        if (pulseCount >= 3) {
          pulseCount = 0;
          pulseWindowT = 0;

          if (!world.started && !world.over) startGame();
          else if (world.over) startGame();
        }
      }
    }

    // Canvas sizing
    let dpr = 1;
    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = Math.max(320, Math.round(rect.width * dpr));
      const h = Math.max(240, Math.round(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      return { w, h };
    }

    // Player state
    const player = { x: 0, y: 0, vy: 0, tilt: 0 };

    const world = {
      started: false,
      over: false,
      survive: 0,

      baseSpeed: 180,
      speedGain: 2,
      speed: 180,

      groundPad: 22,
      topPad: 22,

      distAcc: 0,
      nextSpawnDist: 620,
      obstacles: []
    };

    // Vertical response (speed-adaptive)
    const G = 3600;
    const K_BASE = 80;
    const K_BOOST = 1.05;
    const DAMP_BASE = 12.5;
    const VTERM = 2400;

    // Floaty fall (release-only, fades out with speed)
    const G_FALL_SCALE_MIN = 0.35;
    const G_FALL_CC_MAX = 12;

    function updateHUD() {
      hudTime.textContent = `Time: ${world.survive.toFixed(1)} s`;
      hudSpeed.textContent = `Speed: ${world.speed.toFixed(0)}`;
    }

    function resetGame() {
      world.started = false;
      world.over = false;
      world.survive = 0;
      world.speed = world.baseSpeed;
      world.distAcc = 0;
      world.obstacles = [];
      world.nextSpawnDist = 620;

      player.vy = 0;
      player.tilt = 0;
      resetPulses();

      overlay.style.display = 'grid';
      overlayTitle.textContent = 'Ready';
      overlayText.innerHTML =
        'Start with <span class="kbd">three breath pulses</span>. ' +
        'Backup: <span class="kbd">Space</span> or click. ' +
        'No device: hold <span class="kbd">↑</span> to simulate blowing.';
      updateHUD();
    }

    function startGame() {
      if (world.over) resetGame();
      world.started = true;
      world.over = false;
      overlay.style.display = 'none';
      resetPulses();
      startMusicIfArmed();
    }

    function gameOver() {
      world.over = true;
      world.started = false;
      overlay.style.display = 'grid';
      overlayTitle.textContent = 'Game over';
      overlayText.innerHTML =
        `Survived: <span class="kbd">${world.survive.toFixed(1)} s</span>. ` +
        `Restart with <span class="kbd">three breath pulses</span>, or <span class="kbd">Space</span>, or click.`;
      resetPulses();
      stopMusic();
    }

    function spawnObstacle(w, h) {
      const groundY = h - world.groundPad;
      const ceilingY = world.topPad;

      const gap = 150;
      const kind = (Math.random() < 0.55) ? 'pipe' : 'block';

      if (kind === 'pipe') {
        const pipeW = 56 * dpr;
        const gapCentreMin = ceilingY + 90 * dpr;
        const gapCentreMax = groundY - 90 * dpr;
        const gapCentre = clamp(
          Math.round(gapCentreMin + Math.random() * (gapCentreMax - gapCentreMin)),
          gapCentreMin, gapCentreMax
        );

        const topH = Math.max(20 * dpr, Math.round((gapCentre - (gap * dpr) / 2) - ceilingY));
        const botY = Math.round(gapCentre + (gap * dpr) / 2);
        const botH = Math.max(20 * dpr, Math.round(groundY - botY));

        world.obstacles.push({
          kind: 'pipe',
          x: w + 20 * dpr,
          w: pipeW,
          top: { y: ceilingY, w: pipeW, h: topH },
          bot: { y: botY,     w: pipeW, h: botH }
        });
      } else {
        const blockW = Math.round((46 + Math.random() * 46) * dpr);
        const blockH = Math.round((50 + Math.random() * 140) * dpr);
        world.obstacles.push({
          kind: 'block',
          x: w + 20 * dpr,
          y: groundY - blockH,
          w: blockW,
          h: blockH
        });
      }
    }

    // Ellipse collision against axis-aligned rectangle, with ellipse rotated by theta.
    function ellipseRectHit(cx, cy, a, b, theta, rx, ry, rw, rh) {
      const cosT = Math.cos(-theta);
      const sinT = Math.sin(-theta);

      function toEllipseSpace(x, y) {
        const dx = x - cx;
        const dy = y - cy;
        const ex = dx * cosT - dy * sinT;
        const ey = dx * sinT + dy * cosT;
        return { x: ex, y: ey };
      }
      function insideEllipse(ex, ey) {
        const nx = ex / a;
        const ny = ey / b;
        return (nx * nx + ny * ny) <= 1;
      }

      const corners = [
        [rx, ry],
        [rx + rw, ry],
        [rx, ry + rh],
        [rx + rw, ry + rh],
      ];
      for (const [x, y] of corners) {
        const p = toEllipseSpace(x, y);
        if (insideEllipse(p.x, p.y)) return true;
      }

      const closestX = clamp(cx, rx, rx + rw);
      const closestY = clamp(cy, ry, ry + rh);
      const q = toEllipseSpace(closestX, closestY);
      if (insideEllipse(q.x, q.y)) return true;

      const samplesPerEdge = 3;
      for (let i = 1; i <= samplesPerEdge; i++) {
        const t = i / (samplesPerEdge + 1);

        let sx = rx + t * rw, sy = ry;
        let p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx + t * rw; sy = ry + rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx; sy = ry + t * rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;

        sx = rx + rw; sy = ry + t * rh;
        p = toEllipseSpace(sx, sy);
        if (insideEllipse(p.x, p.y)) return true;
      }

      return false;
    }

    function cssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function drawEllipseDebug(cx, cy, a, b, theta) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(theta);

      ctx.globalAlpha = 0.18;
      ctx.fillStyle = DEBUG_COLL_COLOUR;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 0.85;
      ctx.lineWidth = 2 * dpr;
      ctx.strokeStyle = DEBUG_COLL_COLOUR;
      ctx.beginPath();
      ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(-a, 0);
      ctx.lineTo(a, 0);
      ctx.stroke();

      ctx.restore();
    }

    function drawScene(w, h) {
      ctx.clearRect(0, 0, w, h);

      const groundY = h - world.groundPad;
      const ceilingY = world.topPad;

      const border = cssVar('--border');
      const accentA = cssVar('--accentA');
      const accentB = cssVar('--accentB');
      const text = cssVar('--text');
      const muted = cssVar('--muted');
      const warn = cssVar('--warn');

      // Ground
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = border;
      ctx.lineWidth = 2 * dpr;
      ctx.beginPath();
      ctx.moveTo(0, groundY + 1);
      ctx.lineTo(w, groundY + 1);
      ctx.stroke();
      ctx.restore();

      // Obstacles
      for (const ob of world.obstacles) {
        if (ob.kind === 'pipe') {
          ctx.fillStyle = accentA;
          ctx.fillRect(ob.x, ob.top.y, ob.top.w, ob.top.h);
          ctx.fillStyle = accentB;
          ctx.fillRect(ob.x, ob.bot.y, ob.bot.w, ob.bot.h);

          ctx.strokeStyle = border;
          ctx.lineWidth = 1 * dpr;
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.top.y + 0.5 * dpr, ob.top.w - 1 * dpr, ob.top.h - 1 * dpr);
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.bot.y + 0.5 * dpr, ob.bot.w - 1 * dpr, ob.bot.h - 1 * dpr);
        } else {
          ctx.fillStyle = accentA;
          ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
          ctx.strokeStyle = border;
          ctx.lineWidth = 1 * dpr;
          ctx.strokeRect(ob.x + 0.5 * dpr, ob.y + 0.5 * dpr, ob.w - 1 * dpr, ob.h - 1 * dpr);
        }
      }

      // Player: monkey sprite (fallback circle until loaded)
      const drawW = MONKEY_DRAW_W * dpr;
      const drawH = MONKEY_DRAW_H * dpr;

      if (monkeyReady) {
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.tilt);
        ctx.drawImage(monkeyImg, -drawW / 2, -drawH / 2, drawW, drawH);
        ctx.restore();
      } else {
        ctx.save();
        ctx.fillStyle = text;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 14 * dpr, 0, Math.PI * 2);
        ctx.fill();

        const pct = cc2 / 127;
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = (pct > 0.01) ? warn : muted;
        ctx.beginPath();
        ctx.arc(player.x, player.y, Math.max(3 * dpr, Math.round(14 * dpr * (0.25 + 0.35 * pct))), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Debug collision ellipse (OFF by default)
      if (SHOW_COLLISION_DEBUG) {
        const a = Math.max(8 * dpr, (drawW * COLL_A_FRAC));
        const b = Math.max(6 * dpr, (drawH * COLL_B_FRAC));
        const theta = COLL_ROT + (COLL_FOLLOWS_SPRITE_TILT ? player.tilt : 0);

        const cx = player.x + (drawW * COLL_CX_OFF_FRAC);
        const cy = player.y + (drawH * COLL_CY_OFF_FRAC);

        drawEllipseDebug(cx, cy, a, b, theta);
      }
    }

    // Backup start/restart
    function backupStartOrRestart() {
      if (!world.started && !world.over) startGame();
      else if (world.over) startGame();
    }

    // Keyboard + click
    window.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowUp') simulateKey = true;
      if (e.code === 'Space') {
        e.preventDefault();
        backupStartOrRestart();
      }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowUp') simulateKey = false;
    });
    canvas.addEventListener('pointerdown', backupStartOrRestart);

    // Main loop
    let lastTs = 0;
    function step(ts) {
      const { w, h } = resizeCanvasToDisplaySize();
      const dt = Math.min(0.033, Math.max(0.001, (ts - (lastTs || ts)) / 1000));
      lastTs = ts;

      // Sim fallback: only when user holds ↑
      if (simulateKey) setCC2(90);
      else if (!currentInput) setCC2(0);

      registerPulse(dt);

      const groundY = h - world.groundPad;
      const ceilingY = world.topPad;

      if (!world.started && world.survive === 0 && world.obstacles.length === 0 && !world.over) {
        player.x = Math.round(w * 0.22);
        player.y = groundY - 14 * dpr;
      }

      if (world.started && !world.over) {
        world.survive += dt;
        world.speed = world.baseSpeed + (world.speedGain * world.survive * 10);

        const pct = cc2 / 127;
        const maxLift = (groundY - 14 * dpr) - (ceilingY + 14 * dpr);
        const targetY = (groundY - 14 * dpr) - (pct * maxLift);

        const speedFactor = clamp(world.speed / world.baseSpeed, 1, 3.2);
        const K = K_BASE * (1 + K_BOOST * (speedFactor - 1));
        const DAMP = DAMP_BASE * (0.95 + 0.25 * (speedFactor - 1));

        const speedFade = clamp((speedFactor - 1) / (3.2 - 1), 0, 1);
        const ccFade = clamp(cc2 / G_FALL_CC_MAX, 0, 1);
        const fallScale = (G_FALL_SCALE_MIN + (1 - G_FALL_SCALE_MIN) * ccFade);
        const gEff = G * (fallScale + (1 - fallScale) * speedFade);

        let ay = (K * (targetY - player.y)) - (DAMP * player.vy) + gEff;

        player.vy += ay * dt;
        player.vy = clamp(player.vy, -VTERM * dpr, VTERM * dpr);
        player.y += player.vy * dt;

        player.tilt = clamp(-player.vy / (900 * dpr), -0.20, 0.20);

        const floorY = groundY - 14 * dpr;
        if (player.y > floorY) { player.y = floorY; if (player.vy > 0) player.vy = 0; }
        const ceilY = ceilingY + 14 * dpr;
        if (player.y < ceilY) { player.y = ceilY; if (player.vy < 0) player.vy = 0; }

        const t = world.survive;
        const startMean = 620 * dpr;
        const endMean = 480 * dpr;
        const ease = clamp(t / 18, 0, 1);
        const mean = startMean + (endMean - startMean) * ease;
        const jitter = 0.18;

        world.distAcc += (world.speed * dpr) * dt;
        if (world.distAcc >= world.nextSpawnDist) {
          world.distAcc = 0;
          spawnObstacle(w, h);
          const r = (Math.random() * 2 - 1) * jitter;
          world.nextSpawnDist = Math.max(360 * dpr, mean * (1 + r));
        }

        const dx = (world.speed * dpr) * dt;
        for (const ob of world.obstacles) ob.x -= dx;

        while (world.obstacles.length && (world.obstacles[0].x + (world.obstacles[0].w || world.obstacles[0].top.w)) < -40 * dpr) {
          world.obstacles.shift();
        }

        // Collision
        const drawW = MONKEY_DRAW_W * dpr;
        const drawH = MONKEY_DRAW_H * dpr;
        const a = Math.max(8 * dpr, (drawW * COLL_A_FRAC));
        const b = Math.max(6 * dpr, (drawH * COLL_B_FRAC));
        const collTheta = COLL_ROT + (COLL_FOLLOWS_SPRITE_TILT ? player.tilt : 0);

        const cx = player.x + (drawW * COLL_CX_OFF_FRAC);
        const cy = player.y + (drawH * COLL_CY_OFF_FRAC);

        for (const ob of world.obstacles) {
          if (ob.kind === 'pipe') {
            if (
              ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.top.y, ob.top.w, ob.top.h) ||
              ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.bot.y, ob.bot.w, ob.bot.h)
            ) { gameOver(); break; }
          } else {
            if (ellipseRectHit(cx, cy, a, b, collTheta, ob.x, ob.y, ob.w, ob.h)) {
              gameOver(); break;
            }
          }
        }
      } else {
        player.tilt = 0;
      }

      updateHUD();
      drawScene(w, h);
      requestAnimationFrame(step);
    }

    // ============================================================
    // Single MIDI message handler
    // ============================================================
    function onMIDIMessage(e) {
      const data = e.data;
      if (!data || data.length < 3) return;

      const status = data[0];
      const type = status & 0xF0;

      const targetStatus = 0xB0 | ((targetChannel1Based - 1) & 0x0F);
      if (type === 0xB0 && status === targetStatus && data[1] === targetCC) {
        setCC2(data[2]);
      }
    }

    // Boot
    resetGame();
    setCC2(0);
    requestAnimationFrame(step);
  </script>
</body>
</html>


